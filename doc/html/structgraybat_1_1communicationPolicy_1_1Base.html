<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Graybat: graybat::communicationPolicy::Base&lt; T_CommunicationPolicy &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Graybat
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Graph Approach for Highly Generic Communication Schemes Based on Adaptive Topologies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structgraybat_1_1communicationPolicy_1_1Base.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="structgraybat_1_1communicationPolicy_1_1Base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graybat::communicationPolicy::Base&lt; T_CommunicationPolicy &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8809cc88306f4411eff43b185d4a12ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8809cc88306f4411eff43b185d4a12ba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CommunicationPolicy</b> = T_CommunicationPolicy</td></tr>
<tr class="separator:a8809cc88306f4411eff43b185d4a12ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61555bfaae515788f4832c0f78bc36f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61555bfaae515788f4832c0f78bc36f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VAddr</b> = typename graybat::communicationPolicy::VAddr&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:a61555bfaae515788f4832c0f78bc36f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced4ab808a9c345a0e698d21736f3a2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aced4ab808a9c345a0e698d21736f3a2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Tag</b> = typename graybat::communicationPolicy::Tag&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:aced4ab808a9c345a0e698d21736f3a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a885bada327fddc91cfe4515af6471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a885bada327fddc91cfe4515af6471"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b> = typename graybat::communicationPolicy::Context&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:a12a885bada327fddc91cfe4515af6471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc51f670372dfb2d7f8474a5a0f5e89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fc51f670372dfb2d7f8474a5a0f5e89"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Event</b> = typename graybat::communicationPolicy::Event&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:a2fc51f670372dfb2d7f8474a5a0f5e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Point to Point Communication Interface</div></td></tr>
<tr class="memitem:a7c7b3cd367ec07fa9d12ebbbb89dabb8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c7b3cd367ec07fa9d12ebbbb89dabb8"></a>
template&lt;typename T_Send &gt; </td></tr>
<tr class="memitem:a7c7b3cd367ec07fa9d12ebbbb89dabb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>send</b> (const VAddr destVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, const T_Send &amp;sendData)=delete</td></tr>
<tr class="separator:a7c7b3cd367ec07fa9d12ebbbb89dabb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfe96d75727357e0bbac4f8dad93a55"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7dfe96d75727357e0bbac4f8dad93a55"></a>
template&lt;typename T_Send &gt; </td></tr>
<tr class="memitem:a7dfe96d75727357e0bbac4f8dad93a55"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asyncSend</b> (const VAddr destVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, const T_Send &amp;sendData)=delete</td></tr>
<tr class="separator:a7dfe96d75727357e0bbac4f8dad93a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1785dcc6035447fc3c2b1cd9fee9a4b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1785dcc6035447fc3c2b1cd9fee9a4b5"></a>
template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:a1785dcc6035447fc3c2b1cd9fee9a4b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>recv</b> (const VAddr srcVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, T_Recv &amp;recvData)=delete</td></tr>
<tr class="separator:a1785dcc6035447fc3c2b1cd9fee9a4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7e5b0d65bfa0fcfa3377598eb79882"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c7e5b0d65bfa0fcfa3377598eb79882"></a>
template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:a2c7e5b0d65bfa0fcfa3377598eb79882"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><b>recv</b> (const Context context, T_Recv &amp;recvData)=delete</td></tr>
<tr class="separator:a2c7e5b0d65bfa0fcfa3377598eb79882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee3935d47f527c2802d3b88b546b0a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="adee3935d47f527c2802d3b88b546b0a2"></a>
template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:adee3935d47f527c2802d3b88b546b0a2"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asyncRecv</b> (const VAddr srcVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, T_Recv &amp;recvData)=delete</td></tr>
<tr class="separator:adee3935d47f527c2802d3b88b546b0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective Communication Interface</div></td></tr>
<tr class="memitem:a3db000db20b6cb8fd6e63f3d53e82090"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a3db000db20b6cb8fd6e63f3d53e82090"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a3db000db20b6cb8fd6e63f3d53e82090">gather</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a3db000db20b6cb8fd6e63f3d53e82090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size.  <a href="#a3db000db20b6cb8fd6e63f3d53e82090">More...</a><br /></td></tr>
<tr class="separator:a3db000db20b6cb8fd6e63f3d53e82090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1434994bead59ef38b6eff8346538f0b"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a1434994bead59ef38b6eff8346538f0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a1434994bead59ef38b6eff8346538f0b">gatherVar</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a1434994bead59ef38b6eff8346538f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>.  <a href="#a1434994bead59ef38b6eff8346538f0b">More...</a><br /></td></tr>
<tr class="separator:a1434994bead59ef38b6eff8346538f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b409ea49d7aba2dee0c83e28dda1b65"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a1b409ea49d7aba2dee0c83e28dda1b65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a1b409ea49d7aba2dee0c83e28dda1b65">allGather</a> (Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a1b409ea49d7aba2dee0c83e28dda1b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em>  <a href="#a1b409ea49d7aba2dee0c83e28dda1b65">More...</a><br /></td></tr>
<tr class="separator:a1b409ea49d7aba2dee0c83e28dda1b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bad18907fcc45db9d4a119e726061a8"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a1bad18907fcc45db9d4a119e726061a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a1bad18907fcc45db9d4a119e726061a8">allGatherVar</a> (const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a1bad18907fcc45db9d4a119e726061a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>.  <a href="#a1bad18907fcc45db9d4a119e726061a8">More...</a><br /></td></tr>
<tr class="separator:a1bad18907fcc45db9d4a119e726061a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ed07ce5f107f04926d7b7c39c9834e"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:af1ed07ce5f107f04926d7b7c39c9834e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#af1ed07ce5f107f04926d7b7c39c9834e">scatter</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:af1ed07ce5f107f04926d7b7c39c9834e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data.  <a href="#af1ed07ce5f107f04926d7b7c39c9834e">More...</a><br /></td></tr>
<tr class="separator:af1ed07ce5f107f04926d7b7c39c9834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4aa66d3ed33c810ae48ae762b432b14"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:ac4aa66d3ed33c810ae48ae762b432b14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#ac4aa66d3ed33c810ae48ae762b432b14">allScatter</a> (const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ac4aa66d3ed33c810ae48ae762b432b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data)  <a href="#ac4aa66d3ed33c810ae48ae762b432b14">More...</a><br /></td></tr>
<tr class="separator:ac4aa66d3ed33c810ae48ae762b432b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bf74c91931b35b56fbb54ac535bc14"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </td></tr>
<tr class="memitem:ad3bf74c91931b35b56fbb54ac535bc14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#ad3bf74c91931b35b56fbb54ac535bc14">reduce</a> (const VAddr rootVAddr, const Context context, const T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ad3bf74c91931b35b56fbb54ac535bc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc.  <a href="#ad3bf74c91931b35b56fbb54ac535bc14">More...</a><br /></td></tr>
<tr class="separator:ad3bf74c91931b35b56fbb54ac535bc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77038454619b683f006ba149aea2dcb"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </td></tr>
<tr class="memitem:ac77038454619b683f006ba149aea2dcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#ac77038454619b683f006ba149aea2dcb">allReduce</a> (const Context context, T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ac77038454619b683f006ba149aea2dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers.  <a href="#ac77038454619b683f006ba149aea2dcb">More...</a><br /></td></tr>
<tr class="separator:ac77038454619b683f006ba149aea2dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431ed56b3d5ade805200b565ce98daa0"><td class="memTemplParams" colspan="2">template&lt;typename T_SendRecv &gt; </td></tr>
<tr class="memitem:a431ed56b3d5ade805200b565ce98daa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a431ed56b3d5ade805200b565ce98daa0">broadcast</a> (const VAddr rootVAddr, const Context context, T_SendRecv &amp;data)</td></tr>
<tr class="memdesc:a431ed56b3d5ade805200b565ce98daa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data.  <a href="#a431ed56b3d5ade805200b565ce98daa0">More...</a><br /></td></tr>
<tr class="separator:a431ed56b3d5ade805200b565ce98daa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4e72365c6ad134ba6e31abd8fa2163"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc4e72365c6ad134ba6e31abd8fa2163"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#abc4e72365c6ad134ba6e31abd8fa2163">synchronize</a> (const Context context)</td></tr>
<tr class="memdesc:abc4e72365c6ad134ba6e31abd8fa2163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all peers within <em>context</em> to the same point in the programm execution (barrier). <br /></td></tr>
<tr class="separator:abc4e72365c6ad134ba6e31abd8fa2163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b409ea49d7aba2dee0c83e28dda1b65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::allGather </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>same</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bad18907fcc45db9d4a119e726061a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::allGatherVar </td>
          <td>(</td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac77038454619b683f006ba149aea2dcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::allReduce </td>
          <td>(</td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by all peers. It will have same size of sendData and contains the ith reduced sendData values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4aa66d3ed33c810ae48ae762b432b14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::allScatter </td>
          <td>(</td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that each peer wants to send. Each peer will receive same number of data elements, but not the same data elements. sendData will be divided in equal chunks of data and is then distributed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all peer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a431ed56b3d5ade805200b565ce98daa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_SendRecv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::broadcast </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_SendRecv &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to scatter where every peer receives different data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Source peer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will send to the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3db000db20b6cb8fd6e63f3d53e82090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::gather </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. Data of all peers in the <em>context</em> need to have <b>same</b> size(). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that peer with virtual address <em>rootVAddr</em> will receive. <em>recvData</em> of all other members of the <em>context</em> will be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1434994bead59ef38b6eff8346538f0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::gatherVar </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. The Data can have <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> peers, that peer with <em>rootVAddr</em> will receive. <em>recvData</em> of all other peers of the <em>context</em> will be empty. The received data is ordered by the VAddr of the peers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3bf74c91931b35b56fbb54ac535bc14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that will receive the result of reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by peer with <em>rootVAddr</em>. It will have same size of sendData and contains the ith reduced sendData values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1ed07ce5f107f04926d7b7c39c9834e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base</a>&lt; T_CommunicationPolicy &gt;::scatter </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to broadcast where every peer receives the same data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that want to distribute its data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will distribute over the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/graybat/communicationPolicy/<a class="el" href="Base_8hpp_source.html">Base.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>graybat</b></li><li class="navelem"><b>communicationPolicy</b></li><li class="navelem"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">Base</a></li>
    <li class="footer">Generated on Sat Dec 12 2015 22:20:39 for Graybat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
