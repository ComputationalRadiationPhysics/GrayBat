<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>GrayBat: graybat::communicationPolicy::MinBMPI Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GrayBat
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Graph Approach for Highly Generic Communication Schemes Based on Adaptive Topologies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structgraybat_1_1communicationPolicy_1_1MinBMPI.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="classgraybat_1_1communicationPolicy_1_1MinBMPI-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graybat::communicationPolicy::MinBMPI Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the <a class="el" href="structgraybat_1_1Cage.html" title="The Communication And Graph Environment enables to communicate on basis of a graph with methods of a ...">Cage</a> communicationPolicy interface based on the MPI implementation boost::mpi.  
 <a href="structgraybat_1_1communicationPolicy_1_1MinBMPI.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MinBMPI_8hpp_source.html">MinBMPI.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context represents a set of peers which are able to communicate with each other.  <a href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event is returned by non-blocking communication operations and can be asked whether an operation has finished or it can be waited for this operation to be finished.  <a href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aed5178e73bef1d8db6b0f6b34b92ea0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed5178e73bef1d8db6b0f6b34b92ea0f"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>Tag</b></td></tr>
<tr class="separator:aed5178e73bef1d8db6b0f6b34b92ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e574cb9dc4c1b37c25377d7932673d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e574cb9dc4c1b37c25377d7932673d2"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ContextID</b></td></tr>
<tr class="separator:a2e574cb9dc4c1b37c25377d7932673d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb19cab1cb37cf1bc3550c28b669bbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bb19cab1cb37cf1bc3550c28b669bbe"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>VAddr</b></td></tr>
<tr class="separator:a6bb19cab1cb37cf1bc3550c28b669bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535c0a141d6e97429b7c7fd3ca26723d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a535c0a141d6e97429b7c7fd3ca26723d"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>MsgType</b></td></tr>
<tr class="separator:a535c0a141d6e97429b7c7fd3ca26723d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11917747e10d8d244d51753270ba3024"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11917747e10d8d244d51753270ba3024"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>Uri</b></td></tr>
<tr class="separator:a11917747e10d8d244d51753270ba3024"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective Communication Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Non blocking transmission of a message sendData to peer with virtual address destVAddr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destVAddr</td><td>VAddr of peer that will receive the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data reference of template type T will be. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Event.html" title="An event is returned by non-blocking communication operations and can be asked whether an operation h...">Event</a> Blocking transmission of a message sendData to peer with virtual address destVAddr.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destVAddr</td><td>VAddr of peer that will receive the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data reference of template type T will be send to receiver peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface. Non blocking receive of a message recvData from peer with virtual address srcVAddr.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVAddr</td><td>VAddr of peer that sended the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data reference of template type T will be received from sender peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Event.html" title="An event is returned by non-blocking communication operations and can be asked whether an operation h...">Event</a> Blocking receive of a message recvData from peer with virtual address srcVAddr.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVAddr</td><td>VAddr of peer that sended the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data reference of template type T will be received from sender peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:aa2a60254d0fe94f2055fe45989164047"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:aa2a60254d0fe94f2055fe45989164047"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1MinBMPI.html#aa2a60254d0fe94f2055fe45989164047">allGather</a> (const <a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:aa2a60254d0fe94f2055fe45989164047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size.  <a href="#aa2a60254d0fe94f2055fe45989164047">More...</a><br /></td></tr>
<tr class="separator:aa2a60254d0fe94f2055fe45989164047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b0146f7a8e688ebede83ee0dd8f3ef"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </td></tr>
<tr class="memitem:aa4b0146f7a8e688ebede83ee0dd8f3ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1MinBMPI.html#aa4b0146f7a8e688ebede83ee0dd8f3ef">allReduce</a> (const <a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a> context, T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:aa4b0146f7a8e688ebede83ee0dd8f3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>.  <a href="#aa4b0146f7a8e688ebede83ee0dd8f3ef">More...</a><br /></td></tr>
<tr class="separator:aa4b0146f7a8e688ebede83ee0dd8f3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Context Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to scatter where every peer receives different data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Source peer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will send to the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. Synchronizes all peers within <em>context</em> to the same point in the programm execution (barrier). Synchronizes all peers within the globalContext in the programm execution (barrier).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgraybat_1_1communicationPolicy_1_1MinBMPI.html#a66534cd2818fa9d547cb34c056ed025b" title="Returns the context that contains all peers. ">getGlobalContext()</a> </dd></dl>
</div></td></tr>
<tr class="memitem:ad1861049c3aed2009703135e0286d297"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1861049c3aed2009703135e0286d297"></a>
<a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1MinBMPI.html#ad1861049c3aed2009703135e0286d297">createContext</a> (const std::vector&lt; VAddr &gt; vAddrs, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a> oldContext)</td></tr>
<tr class="memdesc:ad1861049c3aed2009703135e0286d297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new context from peer <em>ids</em> of an <em>oldContext</em> <br /></td></tr>
<tr class="separator:ad1861049c3aed2009703135e0286d297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66534cd2818fa9d547cb34c056ed025b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66534cd2818fa9d547cb34c056ed025b"></a>
<a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1MinBMPI.html#a66534cd2818fa9d547cb34c056ed025b">getGlobalContext</a> ()</td></tr>
<tr class="memdesc:a66534cd2818fa9d547cb34c056ed025b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context that contains all peers. <br /></td></tr>
<tr class="separator:a66534cd2818fa9d547cb34c056ed025b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the <a class="el" href="structgraybat_1_1Cage.html" title="The Communication And Graph Environment enables to communicate on basis of a graph with methods of a ...">Cage</a> communicationPolicy interface based on the MPI implementation boost::mpi. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa2a60254d0fe94f2055fe45989164047"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::MinBMPI::allGather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. Data of all peers in the <em>context</em> need to have <b>same</b> size(). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that peer with virtual address <em>rootVAddr</em> will receive. <em>recvData</em> of all other members of the <em>context</em> will be empty. Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. The Data can have <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> peers, that peer with <em>rootVAddr</em> will receive. <em>recvData</em> of all other peers of the <em>context</em> will be empty. The received data is ordered by the VAddr of the peers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>same</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4b0146f7a8e688ebede83ee0dd8f3ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::MinBMPI::allReduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1MinBMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to broadcast where every peer receives the same data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that want to distribute its data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will distribute over the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that each peer wants to send. Each peer will receive same number of data elements, but not the same data elements. sendData will be divided in equal chunks of data and is then distributed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all peer. Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that will receive the result of reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by peer with <em>rootVAddr</em>. It will have same size of sendData and contains the ith reduced sendData values. Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by all peers. It will have same size of sendData and contains the ith reduced sendData values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/communicationPolicy/<a class="el" href="MinBMPI_8hpp_source.html">MinBMPI.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>graybat</b></li><li class="navelem"><b>communicationPolicy</b></li><li class="navelem"><a class="el" href="structgraybat_1_1communicationPolicy_1_1MinBMPI.html">MinBMPI</a></li>
    <li class="footer">Generated on Wed Apr 29 2015 11:41:44 for GrayBat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
