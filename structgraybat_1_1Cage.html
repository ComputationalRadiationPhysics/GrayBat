<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Graybat: graybat::Cage&lt; T_CommunicationPolicy, T_GraphPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Graybat
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Graph Approach for Highly Generic Communication Schemes Based on Adaptive Topologies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structgraybat_1_1Cage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgraybat_1_1Cage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graybat::Cage&lt; T_CommunicationPolicy, T_GraphPolicy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Communication And Graph Environment enables to communicate on basis of a graph with methods of a user defined communication library.  
 <a href="structgraybat_1_1Cage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cage_8hpp_source.html">Cage.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage_1_1maximum.html">maximum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a848caea3a16ff2390c8b0020cef298f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a848caea3a16ff2390c8b0020cef298f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CommunicationPolicy</b> = T_CommunicationPolicy</td></tr>
<tr class="separator:a848caea3a16ff2390c8b0020cef298f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc98171db17598bd0030d90ff101e4c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc98171db17598bd0030d90ff101e4c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GraphPolicy</b> = T_GraphPolicy</td></tr>
<tr class="separator:afc98171db17598bd0030d90ff101e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7de84bd47f0af51bf87051355424ce9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7de84bd47f0af51bf87051355424ce9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Cage_t</b> = <a class="el" href="structgraybat_1_1Cage.html">Cage</a>&lt; CommunicationPolicy, GraphPolicy &gt;</td></tr>
<tr class="separator:ac7de84bd47f0af51bf87051355424ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd15bbd715221a9d05f2fa5f2d14d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fcd15bbd715221a9d05f2fa5f2d14d5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VAddr</b> = graybat::communicationPolicy::VAddr&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:a5fcd15bbd715221a9d05f2fa5f2d14d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716c512829be5cca5dcbf2a52754d10d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a716c512829be5cca5dcbf2a52754d10d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b> = graybat::communicationPolicy::Context&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:a716c512829be5cca5dcbf2a52754d10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23858450f27e9dfde241521a13df525"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af23858450f27e9dfde241521a13df525"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Event</b> = graybat::communicationPolicy::Event&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:af23858450f27e9dfde241521a13df525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d340120d20ee287043cbaa3e66d27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a425d340120d20ee287043cbaa3e66d27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CPConfig</b> = graybat::communicationPolicy::Config&lt; CommunicationPolicy &gt;</td></tr>
<tr class="separator:a425d340120d20ee287043cbaa3e66d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8a9c50bfa2ac05eb0e36acf2c4f791"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c8a9c50bfa2ac05eb0e36acf2c4f791"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b> = <a class="el" href="structgraybat_1_1CommunicationEdge.html">graybat::CommunicationEdge</a>&lt; <a class="el" href="structgraybat_1_1Cage.html">Cage_t</a> &gt;</td></tr>
<tr class="separator:a1c8a9c50bfa2ac05eb0e36acf2c4f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd9a202873f8a3d1cc5680bc2ac9267"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfd9a202873f8a3d1cc5680bc2ac9267"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b> = <a class="el" href="structgraybat_1_1CommunicationVertex.html">graybat::CommunicationVertex</a>&lt; <a class="el" href="structgraybat_1_1Cage.html">Cage_t</a> &gt;</td></tr>
<tr class="separator:acfd9a202873f8a3d1cc5680bc2ac9267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c3a8d91a9e19c48b760216646b07e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6c3a8d91a9e19c48b760216646b07e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeDescription</b> = graybat::graphPolicy::EdgeDescription&lt; GraphPolicy &gt;</td></tr>
<tr class="separator:ae6c3a8d91a9e19c48b760216646b07e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcd6874d2fbb5a2a731f197aedcb87f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dcd6874d2fbb5a2a731f197aedcb87f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GraphDescription</b> = graybat::graphPolicy::GraphDescription&lt; GraphPolicy &gt;</td></tr>
<tr class="separator:a8dcd6874d2fbb5a2a731f197aedcb87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ae456d67c2804c63a3d651096ec2c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1ae456d67c2804c63a3d651096ec2c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VertexID</b> = graybat::graphPolicy::VertexID</td></tr>
<tr class="separator:ad1ae456d67c2804c63a3d651096ec2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f17dd2b92c84abe4b9d49b2ae6f475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7f17dd2b92c84abe4b9d49b2ae6f475"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeID</b> = graybat::graphPolicy::EdgeID</td></tr>
<tr class="separator:af7f17dd2b92c84abe4b9d49b2ae6f475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af763549ebaa29f10a5c72246c81a8c5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af763549ebaa29f10a5c72246c81a8c5d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GraphID</b> = graybat::graphPolicy::GraphID</td></tr>
<tr class="separator:af763549ebaa29f10a5c72246c81a8c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd2ec48a85543b8521fd85ed7dd1927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcd2ec48a85543b8521fd85ed7dd1927"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Peer</b> = size_t</td></tr>
<tr class="separator:abcd2ec48a85543b8521fd85ed7dd1927"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a5b4f29c8fef120674b95ac25f05518"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a5b4f29c8fef120674b95ac25f05518"></a>
template&lt;class T_Functor &gt; </td></tr>
<tr class="memitem:a4a5b4f29c8fef120674b95ac25f05518"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cage</b> (CPConfig const cpConfig, T_Functor graphFunctor)</td></tr>
<tr class="separator:a4a5b4f29c8fef120674b95ac25f05518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e76d7d8a6dddbb5fbf6882506f80ab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e76d7d8a6dddbb5fbf6882506f80ab1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Cage</b> (CPConfig const cpConfig)</td></tr>
<tr class="separator:a9e76d7d8a6dddbb5fbf6882506f80ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Graph Operations</div></td></tr>
<tr class="memitem:adeb898f46486654a94ee8198d31272fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="adeb898f46486654a94ee8198d31272fb"></a>
template&lt;class T_Functor &gt; </td></tr>
<tr class="memitem:adeb898f46486654a94ee8198d31272fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setGraph</b> (T_Functor graphFunctor)</td></tr>
<tr class="separator:adeb898f46486654a94ee8198d31272fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4558e1f636d7e6db3f0a1fce63a6fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e4558e1f636d7e6db3f0a1fce63a6fb"></a>
std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertices</b> ()</td></tr>
<tr class="separator:a2e4558e1f636d7e6db3f0a1fce63a6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e979baa57c86526fab054a731f59b32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e979baa57c86526fab054a731f59b32"></a>
<a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getVertex</b> (const VertexID vertexID)</td></tr>
<tr class="separator:a1e979baa57c86526fab054a731f59b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe51aef46fbc4e1f2c3c62fcfee15126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe51aef46fbc4e1f2c3c62fcfee15126"></a>
<a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getEdge</b> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> source, const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> target)</td></tr>
<tr class="separator:afe51aef46fbc4e1f2c3c62fcfee15126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bc02fb9875ce4a66e7cfb7d8cbbd99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8bc02fb9875ce4a66e7cfb7d8cbbd99"></a>
std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAdjacentVertices</b> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &amp;v)</td></tr>
<tr class="separator:ad8bc02fb9875ce4a66e7cfb7d8cbbd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21621e29fa96e5334eca259f5ca09b9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21621e29fa96e5334eca259f5ca09b9f"></a>
std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getOutEdges</b> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &amp;v)</td></tr>
<tr class="separator:a21621e29fa96e5334eca259f5ca09b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8873582c6499be4ae375f0d689c2be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d8873582c6499be4ae375f0d689c2be"></a>
std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInEdges</b> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> v)</td></tr>
<tr class="separator:a8d8873582c6499be4ae375f0d689c2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapping Operations</div></td></tr>
<tr class="memitem:afeddcc035e25382462c38c77b481304d"><td class="memTemplParams" colspan="2">template&lt;class T_Functor &gt; </td></tr>
<tr class="memitem:afeddcc035e25382462c38c77b481304d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#afeddcc035e25382462c38c77b481304d">distribute</a> (T_Functor distFunctor)</td></tr>
<tr class="memdesc:afeddcc035e25382462c38c77b481304d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution of the graph vertices to the peers of the global context. The distFunctor it the function responsible for this distribution.  <a href="#afeddcc035e25382462c38c77b481304d">More...</a><br /></td></tr>
<tr class="separator:afeddcc035e25382462c38c77b481304d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8888227acfa41b0a9127a607ca16d32d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a8888227acfa41b0a9127a607ca16d32d">announce</a> (const std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &gt; vertices, const bool global=true)</td></tr>
<tr class="memdesc:a8888227acfa41b0a9127a607ca16d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Announces <em>vertices</em> of a <em>graph</em> to the network, so that other peers know that these <em>vertices</em> are hosted by this peer.  <a href="#a8888227acfa41b0a9127a607ca16d32d">More...</a><br /></td></tr>
<tr class="separator:a8888227acfa41b0a9127a607ca16d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc3bddf2aa1ebbc363a35a35be8fb38"><td class="memItemLeft" align="right" valign="top">VAddr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#aefc3bddf2aa1ebbc363a35a35be8fb38">locateVertex</a> (<a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> vertex)</td></tr>
<tr class="memdesc:aefc3bddf2aa1ebbc363a35a35be8fb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the VAddr of the host of <em>vertex</em> in the graph.  <a href="#aefc3bddf2aa1ebbc363a35a35be8fb38">More...</a><br /></td></tr>
<tr class="separator:aefc3bddf2aa1ebbc363a35a35be8fb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad135a7bfe6929c6dfb0a4ffde2373316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad135a7bfe6929c6dfb0a4ffde2373316"></a>
std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#ad135a7bfe6929c6dfb0a4ffde2373316">getHostedVertices</a> (const VAddr vAddr)</td></tr>
<tr class="memdesc:ad135a7bfe6929c6dfb0a4ffde2373316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opposite operation of <a class="el" href="structgraybat_1_1Cage.html#aefc3bddf2aa1ebbc363a35a35be8fb38" title="Returns the VAddr of the host of vertex in the graph. ">locateVertex()</a>. It returns the vertices that are hosted by the peer with <em>vAddr</em> <br /></td></tr>
<tr class="separator:ad135a7bfe6929c6dfb0a4ffde2373316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0aa8d61511ba1e2593fb45e694aa16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf0aa8d61511ba1e2593fb45e694aa16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#abf0aa8d61511ba1e2593fb45e694aa16">peerHostsVertex</a> (<a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> vertex)</td></tr>
<tr class="memdesc:abf0aa8d61511ba1e2593fb45e694aa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>vertex</em> is hosted by the calling peer otherwise false. <br /></td></tr>
<tr class="separator:abf0aa8d61511ba1e2593fb45e694aa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eef0dae96d63420aaee9bdc95f7f977"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eef0dae96d63420aaee9bdc95f7f977"></a>
std::vector&lt; Peer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPeers</b> ()</td></tr>
<tr class="separator:a2eef0dae96d63420aaee9bdc95f7f977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Point to Point Communication Operations</div></td></tr>
<tr class="memitem:ab9a114ae8076ccbe9b233c68ff2d155b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9a114ae8076ccbe9b233c68ff2d155b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#ab9a114ae8076ccbe9b233c68ff2d155b">send</a> (const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a> edge, const T &amp;data)</td></tr>
<tr class="memdesc:ab9a114ae8076ccbe9b233c68ff2d155b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>.  <a href="#ab9a114ae8076ccbe9b233c68ff2d155b">More...</a><br /></td></tr>
<tr class="separator:ab9a114ae8076ccbe9b233c68ff2d155b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd6352f368e4d3cafa3ba26f54c6e93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbd6352f368e4d3cafa3ba26f54c6e93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#abbd6352f368e4d3cafa3ba26f54c6e93">send</a> (const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a> edge, const T &amp;data, std::vector&lt; Event &gt; &amp;events)</td></tr>
<tr class="memdesc:abbd6352f368e4d3cafa3ba26f54c6e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>.  <a href="#abbd6352f368e4d3cafa3ba26f54c6e93">More...</a><br /></td></tr>
<tr class="separator:abbd6352f368e4d3cafa3ba26f54c6e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3085ae78588c6bc49aae16391abc52f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3085ae78588c6bc49aae16391abc52f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#aa3085ae78588c6bc49aae16391abc52f">recv</a> (const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a> edge, T &amp;data)</td></tr>
<tr class="memdesc:aa3085ae78588c6bc49aae16391abc52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>.  <a href="#aa3085ae78588c6bc49aae16391abc52f">More...</a><br /></td></tr>
<tr class="separator:aa3085ae78588c6bc49aae16391abc52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6714c94d1ae252456f7801e47cbee345"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6714c94d1ae252456f7801e47cbee345"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6714c94d1ae252456f7801e47cbee345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>recv</b> (T &amp;data)</td></tr>
<tr class="separator:a6714c94d1ae252456f7801e47cbee345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c895e002001d07877f7dd311a3c279f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c895e002001d07877f7dd311a3c279f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a0c895e002001d07877f7dd311a3c279f">recv</a> (const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a> edge, T &amp;data, std::vector&lt; Event &gt; &amp;events)</td></tr>
<tr class="memdesc:a0c895e002001d07877f7dd311a3c279f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>.  <a href="#a0c895e002001d07877f7dd311a3c279f">More...</a><br /></td></tr>
<tr class="separator:a0c895e002001d07877f7dd311a3c279f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective Communication Operations</div></td></tr>
<tr class="memitem:a36fa784cb2d80c8f18005729d1035fee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a36fa784cb2d80c8f18005729d1035fee"></a>
template&lt;typename T_Data , typename Op &gt; </td></tr>
<tr class="memitem:a36fa784cb2d80c8f18005729d1035fee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce</b> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> rootVertex, const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> srcVertex, Op op, const std::vector&lt; T_Data &gt; sendData, std::vector&lt; T_Data &gt; &amp;recvData)</td></tr>
<tr class="separator:a36fa784cb2d80c8f18005729d1035fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaefc0dd7e23f1125dabcb9002ad45f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeaefc0dd7e23f1125dabcb9002ad45f2"></a>
template&lt;typename T_Data , typename T_Recv , typename Op &gt; </td></tr>
<tr class="memitem:aeaefc0dd7e23f1125dabcb9002ad45f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allReduce</b> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> srcVertex, Op op, const std::vector&lt; T_Data &gt; sendData, T_Recv &amp;recvData)</td></tr>
<tr class="separator:aeaefc0dd7e23f1125dabcb9002ad45f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa828d0331211a8388b21cee321d8edb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa828d0331211a8388b21cee321d8edb9"></a>
template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:aa828d0331211a8388b21cee321d8edb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gather</b> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> rootVertex, const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> srcVertex, const T_Send sendData, T_Recv &amp;recvData, const bool reorder)</td></tr>
<tr class="separator:aa828d0331211a8388b21cee321d8edb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b8858bb4ae33204c049c50c1a27aca"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a57b8858bb4ae33204c049c50c1a27aca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a57b8858bb4ae33204c049c50c1a27aca">allGather</a> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> srcVertex, T_Send sendData, T_Recv &amp;recvData, const bool reorder)</td></tr>
<tr class="separator:a57b8858bb4ae33204c049c50c1a27aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7530589eef3e5d7dc1e70adb74c75f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7530589eef3e5d7dc1e70adb74c75f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#ad7530589eef3e5d7dc1e70adb74c75f4">spread</a> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> vertex, const T &amp;data, std::vector&lt; Event &gt; &amp;events)</td></tr>
<tr class="memdesc:ad7530589eef3e5d7dc1e70adb74c75f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread data from a vertex to all adjacent vertices connected by an outgoing edge (async).  <a href="#ad7530589eef3e5d7dc1e70adb74c75f4">More...</a><br /></td></tr>
<tr class="separator:ad7530589eef3e5d7dc1e70adb74c75f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa387169a4a053f30479ff478aa8d5cf8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa387169a4a053f30479ff478aa8d5cf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#aa387169a4a053f30479ff478aa8d5cf8">spread</a> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> vertex, const T &amp;data)</td></tr>
<tr class="memdesc:aa387169a4a053f30479ff478aa8d5cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread data from a vertex to all adjacent vertices connected by an outgoing edge (sync).  <a href="#aa387169a4a053f30479ff478aa8d5cf8">More...</a><br /></td></tr>
<tr class="separator:aa387169a4a053f30479ff478aa8d5cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7eaa7c2302a32e5408bb92ae4b6f53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b7eaa7c2302a32e5408bb92ae4b6f53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a9b7eaa7c2302a32e5408bb92ae4b6f53">collect</a> (const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> vertex, T &amp;data)</td></tr>
<tr class="memdesc:a9b7eaa7c2302a32e5408bb92ae4b6f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects data from all incoming edges under the assumption that all vertices send the same number of data.  <a href="#a9b7eaa7c2302a32e5408bb92ae4b6f53">More...</a><br /></td></tr>
<tr class="separator:a9b7eaa7c2302a32e5408bb92ae4b6f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a8d9fcfbb52bddb37c882d76e940f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13a8d9fcfbb52bddb37c882d76e940f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronize</b> ()</td></tr>
<tr class="separator:a13a8d9fcfbb52bddb37c882d76e940f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f5edf7c4ff86661198e53ba20109e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44f5edf7c4ff86661198e53ba20109e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ContextID</b> ()</td></tr>
<tr class="separator:a44f5edf7c4ff86661198e53ba20109e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a814df63d13307540a09a734365c6bc17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a814df63d13307540a09a734365c6bc17"></a>
CommunicationPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>comm</b></td></tr>
<tr class="separator:a814df63d13307540a09a734365c6bc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65609fabcd12ea956a50dfc9f7f8822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac65609fabcd12ea956a50dfc9f7f8822"></a>
GraphPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>graph</b></td></tr>
<tr class="separator:ac65609fabcd12ea956a50dfc9f7f8822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae110547d929e8f93c4d43b5c7f5012"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae110547d929e8f93c4d43b5c7f5012"></a>
Context&#160;</td><td class="memItemRight" valign="bottom"><b>graphContext</b></td></tr>
<tr class="separator:aaae110547d929e8f93c4d43b5c7f5012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae38e3176ae872f115bc277ed896c99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acae38e3176ae872f115bc277ed896c99"></a>
std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hostedVertices</b></td></tr>
<tr class="separator:acae38e3176ae872f115bc277ed896c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ab4a85708473a09befb09b2d41d2e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39ab4a85708473a09befb09b2d41d2e5"></a>
std::map&lt; VertexID, VAddr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexMap</b></td></tr>
<tr class="separator:a39ab4a85708473a09befb09b2d41d2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8f8f77d9b63e53b855c306cb21bda6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac8f8f77d9b63e53b855c306cb21bda6"></a>
std::map&lt; GraphID, Context &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>graphMap</b></td></tr>
<tr class="separator:aac8f8f77d9b63e53b855c306cb21bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cbddbcb1a81ac31b0c6307fd3df542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0cbddbcb1a81ac31b0c6307fd3df542"></a>
std::map&lt; VAddr, std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>peerMap</b></td></tr>
<tr class="separator:af0cbddbcb1a81ac31b0c6307fd3df542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T_CommunicationPolicy, typename T_GraphPolicy&gt;<br />
class graybat::Cage&lt; T_CommunicationPolicy, T_GraphPolicy &gt;</h3>

<p>The Communication And Graph Environment enables to communicate on basis of a graph with methods of a user defined communication library. </p>
<p>A cage is defined by its Communication and Graph policy. The communication policy provides methods for point to point and collective operations. The graph policy provides methods to query graph imformation of the cage graph.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A peer can host several vertices. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="anyrecv_8cpp-example.html#_a3">anyrecv.cpp</a>, <a class="el" href="chain_8cpp-example.html#_a3">chain.cpp</a>, <a class="el" href="forward_8cpp-example.html#_a3">forward.cpp</a>, <a class="el" href="gol_8cpp-example.html#_a3">gol.cpp</a>, and <a class="el" href="ring_8cpp-example.html#_a3">ring.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a57b8858bb4ae33204c049c50c1a27aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::allGather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>srcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Send&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8888227acfa41b0a9127a607ca16d32d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::announce </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>global</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Announces <em>vertices</em> of a <em>graph</em> to the network, so that other peers know that these <em>vertices</em> are hosted by this peer. </p>
<p>The general workflow includes two steps:</p><ol type="1">
<li>Each peer, that hosts vertices of the <em>graph</em> announces its <em>vertices</em><ul>
<li>Each peer will send its hosted vertices and update its vertices location</li>
<li>The host peers will create a new context for <em>graph</em></li>
</ul>
</li>
<li>Vertices can now be located by <a class="el" href="structgraybat_1_1Cage.html#aefc3bddf2aa1ebbc363a35a35be8fb38" title="Returns the VAddr of the host of vertex in the graph. ">locateVertex()</a></li>
<li>use Graphpeer to communicate between vertices</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>This is a collective Operation on which either all host peers of the supergraph of <em>graph</em> have to take part or when <em>graph</em> has no supergraph then all Communicatos from the globalContext (which should be all peers in the network).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>Its vertices will be announced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>A set of vertices, that will be hosted by this peer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b7eaa7c2302a32e5408bb92ae4b6f53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::collect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects data from all incoming edges under the assumption that all vertices send the same number of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>that collects data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>were collected data will be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afeddcc035e25382462c38c77b481304d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;class T_Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::distribute </td>
          <td>(</td>
          <td class="paramtype">T_Functor&#160;</td>
          <td class="paramname"><em>distFunctor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distribution of the graph vertices to the peers of the global context. The distFunctor it the function responsible for this distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distFunctor</td><td><a class="el" href="structFunction.html">Function</a> for vertex distribution with the following interface: distFunctor(OwnVAddr, ContextSize, Graph) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefc3bddf2aa1ebbc363a35a35be8fb38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VAddr <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::locateVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the VAddr of the host of <em>vertex</em> in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>Will be located. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3085ae78588c6bc49aae16391abc52f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Data that will be received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c895e002001d07877f7dd311a3c279f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Event &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Data that will be received </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">List</td><td>of events the send event will be added to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9a114ae8076ccbe9b233c68ff2d155b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data that will be send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbd6352f368e4d3cafa3ba26f54c6e93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationEdge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Event &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data that will be send. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">List</td><td>of events the send event will be added to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7530589eef3e5d7dc1e70adb74c75f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::spread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Event &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spread data from a vertex to all adjacent vertices connected by an outgoing edge (async). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>to spread data from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>that will be spreaded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>where the events for this async operations will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa387169a4a053f30479ff478aa8d5cf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::spread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgraybat_1_1CommunicationVertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spread data from a vertex to all adjacent vertices connected by an outgoing edge (sync). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>to spread data from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>that will be spreaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/graybat/<a class="el" href="Cage_8hpp_source.html">Cage.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>graybat</b></li><li class="navelem"><a class="el" href="structgraybat_1_1Cage.html">Cage</a></li>
    <li class="footer">Generated on Sat Dec 12 2015 23:23:15 for Graybat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
