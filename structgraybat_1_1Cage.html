<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>GrayBat: graybat::Cage&lt; T_CommunicationPolicy, T_GraphPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GrayBat
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Graph Approach for Highly Generic Communication Schemes Based on Adaptive Topologies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structgraybat_1_1Cage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgraybat_1_1Cage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graybat::Cage&lt; T_CommunicationPolicy, T_GraphPolicy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Communication And Graph Environment enables to communicate on basis of a graph with methods of a user defined communication library.  
 <a href="structgraybat_1_1Cage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Cage_8hpp_source.html">Cage.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage_1_1maximum.html">maximum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a16e713dc5f2d75d814107f84a5dba4a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e713dc5f2d75d814107f84a5dba4a9"></a>
typedef T_CommunicationPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>CommunicationPolicy</b></td></tr>
<tr class="separator:a16e713dc5f2d75d814107f84a5dba4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e655731220c778de4ad72777920b6d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e655731220c778de4ad72777920b6d2"></a>
typedef T_GraphPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>GraphPolicy</b></td></tr>
<tr class="separator:a1e655731220c778de4ad72777920b6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63e3a7fc5fefcea4a55138037f08a39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac63e3a7fc5fefcea4a55138037f08a39"></a>
typedef GraphPolicy::Vertex&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="separator:ac63e3a7fc5fefcea4a55138037f08a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2fbd34cdae1b7fbbf1952ec3993d82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f2fbd34cdae1b7fbbf1952ec3993d82"></a>
typedef GraphPolicy::Edge&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="separator:a9f2fbd34cdae1b7fbbf1952ec3993d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254aa448502586d0796afb8ccd2670c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a254aa448502586d0796afb8ccd2670c2"></a>
typedef GraphPolicy::GraphID&#160;</td><td class="memItemRight" valign="bottom"><b>GraphID</b></td></tr>
<tr class="separator:a254aa448502586d0796afb8ccd2670c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee50f9e944dc428422021d52f5f39f36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee50f9e944dc428422021d52f5f39f36"></a>
typedef GraphPolicy::EdgeDescription&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeDescription</b></td></tr>
<tr class="separator:aee50f9e944dc428422021d52f5f39f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97148cf0ef23d3839dc5c9fbcf5d436d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97148cf0ef23d3839dc5c9fbcf5d436d"></a>
typedef GraphPolicy::GraphDescription&#160;</td><td class="memItemRight" valign="bottom"><b>GraphDescription</b></td></tr>
<tr class="separator:a97148cf0ef23d3839dc5c9fbcf5d436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fc9cc27dcbd7e1c8c28c397bf7a301"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58fc9cc27dcbd7e1c8c28c397bf7a301"></a>
typedef Vertex::ID&#160;</td><td class="memItemRight" valign="bottom"><b>VertexID</b></td></tr>
<tr class="separator:a58fc9cc27dcbd7e1c8c28c397bf7a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5eb390707c39e7f0536ed06ce2cb12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f5eb390707c39e7f0536ed06ce2cb12"></a>
typedef CommunicationPolicy::VAddr&#160;</td><td class="memItemRight" valign="bottom"><b>VAddr</b></td></tr>
<tr class="separator:a9f5eb390707c39e7f0536ed06ce2cb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24653eb9744facb5358b973b002698eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24653eb9744facb5358b973b002698eb"></a>
typedef CommunicationPolicy::Event&#160;</td><td class="memItemRight" valign="bottom"><b>Event</b></td></tr>
<tr class="separator:a24653eb9744facb5358b973b002698eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d39b67a9920a8319ff3b34fbb5d4c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63d39b67a9920a8319ff3b34fbb5d4c2"></a>
typedef CommunicationPolicy::Context&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b></td></tr>
<tr class="separator:a63d39b67a9920a8319ff3b34fbb5d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65da5375af1e87393d1c5f28a14961c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65da5375af1e87393d1c5f28a14961c7"></a>
typedef CommunicationPolicy::ContextID&#160;</td><td class="memItemRight" valign="bottom"><b>ContextID</b></td></tr>
<tr class="separator:a65da5375af1e87393d1c5f28a14961c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a7afb409cd54c75e1e5cac4980d0099"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1a7afb409cd54c75e1e5cac4980d0099"></a>
template&lt;class T_Functor &gt; </td></tr>
<tr class="memitem:a1a7afb409cd54c75e1e5cac4980d0099"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cage</b> (T_Functor graphFunctor)</td></tr>
<tr class="separator:a1a7afb409cd54c75e1e5cac4980d0099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Graph Operations</div></td></tr>
<tr class="memitem:a2e4558e1f636d7e6db3f0a1fce63a6fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e4558e1f636d7e6db3f0a1fce63a6fb"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertices</b> ()</td></tr>
<tr class="separator:a2e4558e1f636d7e6db3f0a1fce63a6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e979baa57c86526fab054a731f59b32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e979baa57c86526fab054a731f59b32"></a>
Vertex&#160;</td><td class="memItemRight" valign="bottom"><b>getVertex</b> (const VertexID vertexID)</td></tr>
<tr class="separator:a1e979baa57c86526fab054a731f59b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab711f85e41f616d7162b976ac6c80147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab711f85e41f616d7162b976ac6c80147"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAdjacentVertices</b> (const Vertex v)</td></tr>
<tr class="separator:ab711f85e41f616d7162b976ac6c80147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0bf92750d5d311e541a201a156c5d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc0bf92750d5d311e541a201a156c5d0"></a>
std::vector&lt; std::pair&lt; Vertex, Edge &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getOutEdges</b> (const Vertex v)</td></tr>
<tr class="separator:acc0bf92750d5d311e541a201a156c5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4369eb837f41d2761baa53f7aa012d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4369eb837f41d2761baa53f7aa012d7"></a>
std::vector&lt; std::pair&lt; Vertex, Edge &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInEdges</b> (const Vertex v)</td></tr>
<tr class="separator:ad4369eb837f41d2761baa53f7aa012d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapping Operations</div></td></tr>
<tr class="memitem:afeddcc035e25382462c38c77b481304d"><td class="memTemplParams" colspan="2">template&lt;class T_Functor &gt; </td></tr>
<tr class="memitem:afeddcc035e25382462c38c77b481304d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#afeddcc035e25382462c38c77b481304d">distribute</a> (T_Functor distFunctor)</td></tr>
<tr class="memdesc:afeddcc035e25382462c38c77b481304d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution of the graph vertices to the peers of the global context. The distFunctor it the function responsible for this distribution.  <a href="#afeddcc035e25382462c38c77b481304d">More...</a><br /></td></tr>
<tr class="separator:afeddcc035e25382462c38c77b481304d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8888227acfa41b0a9127a607ca16d32d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a8888227acfa41b0a9127a607ca16d32d">announce</a> (const std::vector&lt; Vertex &gt; vertices, const bool global=true)</td></tr>
<tr class="memdesc:a8888227acfa41b0a9127a607ca16d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Announces <em>vertices</em> of a <em>graph</em> to the network, so that other peers know that these <em>vertices</em> are hosted by this peer.  <a href="#a8888227acfa41b0a9127a607ca16d32d">More...</a><br /></td></tr>
<tr class="separator:a8888227acfa41b0a9127a607ca16d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc3bddf2aa1ebbc363a35a35be8fb38"><td class="memItemLeft" align="right" valign="top">VAddr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#aefc3bddf2aa1ebbc363a35a35be8fb38">locateVertex</a> (Vertex vertex)</td></tr>
<tr class="memdesc:aefc3bddf2aa1ebbc363a35a35be8fb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the VAddr of the host of <em>vertex</em> in the graph.  <a href="#aefc3bddf2aa1ebbc363a35a35be8fb38">More...</a><br /></td></tr>
<tr class="separator:aefc3bddf2aa1ebbc363a35a35be8fb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad135a7bfe6929c6dfb0a4ffde2373316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad135a7bfe6929c6dfb0a4ffde2373316"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#ad135a7bfe6929c6dfb0a4ffde2373316">getHostedVertices</a> (const VAddr vAddr)</td></tr>
<tr class="memdesc:ad135a7bfe6929c6dfb0a4ffde2373316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opposite operation of <a class="el" href="structgraybat_1_1Cage.html#aefc3bddf2aa1ebbc363a35a35be8fb38" title="Returns the VAddr of the host of vertex in the graph. ">locateVertex()</a>. It returns the vertices that are hosted by the peer with <em>vAddr</em> <br /></td></tr>
<tr class="separator:ad135a7bfe6929c6dfb0a4ffde2373316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0aa8d61511ba1e2593fb45e694aa16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf0aa8d61511ba1e2593fb45e694aa16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#abf0aa8d61511ba1e2593fb45e694aa16">peerHostsVertex</a> (Vertex vertex)</td></tr>
<tr class="memdesc:abf0aa8d61511ba1e2593fb45e694aa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>vertex</em> is hosted by the calling peer otherwise false. <br /></td></tr>
<tr class="separator:abf0aa8d61511ba1e2593fb45e694aa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Point to Point Communication Operations</div></td></tr>
<tr class="memitem:a6e66c334ec691727c0f5ae5f193563e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e66c334ec691727c0f5ae5f193563e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a6e66c334ec691727c0f5ae5f193563e0">send</a> (const Vertex destVertex, const Edge edge, const T &amp;data)</td></tr>
<tr class="memdesc:a6e66c334ec691727c0f5ae5f193563e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>.  <a href="#a6e66c334ec691727c0f5ae5f193563e0">More...</a><br /></td></tr>
<tr class="separator:a6e66c334ec691727c0f5ae5f193563e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad026fc8ab52c084c1c79fbdd4267ad61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad026fc8ab52c084c1c79fbdd4267ad61"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#ad026fc8ab52c084c1c79fbdd4267ad61">asyncSend</a> (const Vertex destVertex, const Edge edge, const T &amp;data)</td></tr>
<tr class="memdesc:ad026fc8ab52c084c1c79fbdd4267ad61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>.  <a href="#ad026fc8ab52c084c1c79fbdd4267ad61">More...</a><br /></td></tr>
<tr class="separator:ad026fc8ab52c084c1c79fbdd4267ad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1290597f9fd45b47d94e3e4cc429b592"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1290597f9fd45b47d94e3e4cc429b592"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a1290597f9fd45b47d94e3e4cc429b592">recv</a> (const Vertex srcVertex, const Edge edge, T &amp;data)</td></tr>
<tr class="memdesc:a1290597f9fd45b47d94e3e4cc429b592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>.  <a href="#a1290597f9fd45b47d94e3e4cc429b592">More...</a><br /></td></tr>
<tr class="separator:a1290597f9fd45b47d94e3e4cc429b592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e84ae6d366218ab95be389ff8302b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18e84ae6d366218ab95be389ff8302b8"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a18e84ae6d366218ab95be389ff8302b8">asypncRecv</a> (const Vertex srcVertex, const Edge edge, T &amp;data)</td></tr>
<tr class="memdesc:a18e84ae6d366218ab95be389ff8302b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>.  <a href="#a18e84ae6d366218ab95be389ff8302b8">More...</a><br /></td></tr>
<tr class="separator:a18e84ae6d366218ab95be389ff8302b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective Communication Operations</div></td></tr>
<tr class="memitem:a36fa784cb2d80c8f18005729d1035fee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a36fa784cb2d80c8f18005729d1035fee"></a>
template&lt;typename T_Data , typename Op &gt; </td></tr>
<tr class="memitem:a36fa784cb2d80c8f18005729d1035fee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce</b> (const Vertex rootVertex, const Vertex srcVertex, Op op, const std::vector&lt; T_Data &gt; sendData, std::vector&lt; T_Data &gt; &amp;recvData)</td></tr>
<tr class="separator:a36fa784cb2d80c8f18005729d1035fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaefc0dd7e23f1125dabcb9002ad45f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeaefc0dd7e23f1125dabcb9002ad45f2"></a>
template&lt;typename T_Data , typename T_Recv , typename Op &gt; </td></tr>
<tr class="memitem:aeaefc0dd7e23f1125dabcb9002ad45f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allReduce</b> (const Vertex srcVertex, Op op, const std::vector&lt; T_Data &gt; sendData, T_Recv &amp;recvData)</td></tr>
<tr class="separator:aeaefc0dd7e23f1125dabcb9002ad45f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa828d0331211a8388b21cee321d8edb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa828d0331211a8388b21cee321d8edb9"></a>
template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:aa828d0331211a8388b21cee321d8edb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gather</b> (const Vertex rootVertex, const Vertex srcVertex, const T_Send sendData, T_Recv &amp;recvData, const bool reorder)</td></tr>
<tr class="separator:aa828d0331211a8388b21cee321d8edb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b8858bb4ae33204c049c50c1a27aca"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a57b8858bb4ae33204c049c50c1a27aca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1Cage.html#a57b8858bb4ae33204c049c50c1a27aca">allGather</a> (const Vertex srcVertex, T_Send sendData, T_Recv &amp;recvData, const bool reorder)</td></tr>
<tr class="separator:a57b8858bb4ae33204c049c50c1a27aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a8d9fcfbb52bddb37c882d76e940f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13a8d9fcfbb52bddb37c882d76e940f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronize</b> ()</td></tr>
<tr class="separator:a13a8d9fcfbb52bddb37c882d76e940f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a814df63d13307540a09a734365c6bc17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a814df63d13307540a09a734365c6bc17"></a>
CommunicationPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>comm</b></td></tr>
<tr class="separator:a814df63d13307540a09a734365c6bc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65609fabcd12ea956a50dfc9f7f8822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac65609fabcd12ea956a50dfc9f7f8822"></a>
GraphPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>graph</b></td></tr>
<tr class="separator:ac65609fabcd12ea956a50dfc9f7f8822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae110547d929e8f93c4d43b5c7f5012"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae110547d929e8f93c4d43b5c7f5012"></a>
Context&#160;</td><td class="memItemRight" valign="bottom"><b>graphContext</b></td></tr>
<tr class="separator:aaae110547d929e8f93c4d43b5c7f5012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae38e3176ae872f115bc277ed896c99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acae38e3176ae872f115bc277ed896c99"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hostedVertices</b></td></tr>
<tr class="separator:acae38e3176ae872f115bc277ed896c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ab4a85708473a09befb09b2d41d2e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39ab4a85708473a09befb09b2d41d2e5"></a>
std::map&lt; VertexID, VAddr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexMap</b></td></tr>
<tr class="separator:a39ab4a85708473a09befb09b2d41d2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8f8f77d9b63e53b855c306cb21bda6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac8f8f77d9b63e53b855c306cb21bda6"></a>
std::map&lt; GraphID, Context &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>graphMap</b></td></tr>
<tr class="separator:aac8f8f77d9b63e53b855c306cb21bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cbddbcb1a81ac31b0c6307fd3df542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0cbddbcb1a81ac31b0c6307fd3df542"></a>
std::map&lt; VAddr, std::vector&lt; Vertex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>peerMap</b></td></tr>
<tr class="separator:af0cbddbcb1a81ac31b0c6307fd3df542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T_CommunicationPolicy, typename T_GraphPolicy&gt;<br />
class graybat::Cage&lt; T_CommunicationPolicy, T_GraphPolicy &gt;</h3>

<p>The Communication And Graph Environment enables to communicate on basis of a graph with methods of a user defined communication library. </p>
<p>A cage is defined by its Communication and Graph policy. The communication policy provides methods for point to point and collective operations. The graph policy provides methods to query graph imformation of the cage graph.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A peer can host several vertices. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="gol_8cc-example.html#_a3">gol.cc</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a57b8858bb4ae33204c049c50c1a27aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::allGather </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>srcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Send&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8888227acfa41b0a9127a607ca16d32d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::announce </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Vertex &gt;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>global</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Announces <em>vertices</em> of a <em>graph</em> to the network, so that other peers know that these <em>vertices</em> are hosted by this peer. </p>
<p>The general workflow includes two steps:</p><ol type="1">
<li>Each peer, that hosts vertices of the <em>graph</em> announces its <em>vertices</em><ul>
<li>Each peer will send its hosted vertices and update its vertices location</li>
<li>The host peers will create a new context for <em>graph</em></li>
</ul>
</li>
<li>Vertices can now be located by <a class="el" href="structgraybat_1_1Cage.html#aefc3bddf2aa1ebbc363a35a35be8fb38" title="Returns the VAddr of the host of vertex in the graph. ">locateVertex()</a></li>
<li>use Graphpeer to communicate between vertices</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>This is a collective Operation on which either all host peers of the supergraph of <em>graph</em> have to take part or when <em>graph</em> has no supergraph then all Communicatos from the globalContext (which should be all peers in the network).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>Its vertices will be announced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>A set of vertices, that will be hosted by this peer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad026fc8ab52c084c1c79fbdd4267ad61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Event <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::asyncSend </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>destVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edge&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destVertex</td><td>Vertex that will receive the <em>data</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data that will be send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event Can be waited (Event::wait()) for or checked for (Event::ready()) </dd></dl>

</div>
</div>
<a class="anchor" id="a18e84ae6d366218ab95be389ff8302b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Event <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::asypncRecv </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>srcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edge&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVertex</td><td>Vertex that send the <em>data</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Data that will be received</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event Can be waited (Event::wait()) for or checked for (Event::ready()) </dd></dl>

</div>
</div>
<a class="anchor" id="afeddcc035e25382462c38c77b481304d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;class T_Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::distribute </td>
          <td>(</td>
          <td class="paramtype">T_Functor&#160;</td>
          <td class="paramname"><em>distFunctor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distribution of the graph vertices to the peers of the global context. The distFunctor it the function responsible for this distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distFunctor</td><td>Function for vertex distribution with the following interface: distFunctor(OwnVAddr, ContextSize, Graph) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefc3bddf2aa1ebbc363a35a35be8fb38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VAddr <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::locateVertex </td>
          <td>(</td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the VAddr of the host of <em>vertex</em> in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>Will be located. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1290597f9fd45b47d94e3e4cc429b592"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>srcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edge&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchron receive of <em>data</em> from the <em>srcVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVertex</td><td>Vertex that send the <em>data</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Data that will be received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e66c334ec691727c0f5ae5f193563e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_CommunicationPolicy , typename T_GraphPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraybat_1_1Cage.html">graybat::Cage</a>&lt; T_CommunicationPolicy, T_GraphPolicy &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>destVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edge&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchron transmission of <em>data</em> to the <em>destVertex</em> on <em>edge</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The graph in which the communication takes place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destVertex</td><td>Vertex that will receive the <em>data</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>Edge over which the <em>data</em> will be transmitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data that will be send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="Cage_8hpp_source.html">Cage.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>graybat</b></li><li class="navelem"><a class="el" href="structgraybat_1_1Cage.html">Cage</a></li>
    <li class="footer">Generated on Wed Apr 29 2015 13:55:23 for GrayBat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
