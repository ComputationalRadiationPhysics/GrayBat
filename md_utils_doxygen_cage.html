<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>GrayBat: Communication and Graph Environment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GrayBat
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Graph Approach for Highly Generic Communication Schemes Based on Adaptive Topologies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_utils_doxygen_cage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Communication and Graph Environment </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The communication and graph environment (<a class="el" href="structgraybat_1_1Cage.html">cage</a>) provides a graph-based virtual overlay network which is implemented by the policy based design. Taking this term to pieces, the <a class="el" href="structgraybat_1_1Cage.html">cage</a> is an interface which provides communication methods on basis of an existing communication library, where the possible paths of communication are described by a graph.</p>
<p>The behavior of the <a class="el" href="structgraybat_1_1Cage.html">cage</a> need to be defined by a <a class="el" href="communicationPolicy.html">communication policy</a> and a <a class="el" href="graphPolicy.html">graph policy</a>. These policies need to be provided as template arguments to the <a class="el" href="structgraybat_1_1Cage.html">cage</a> class. The following listings show examples on how to use and how to configure the <a class="el" href="structgraybat_1_1Cage.html">cage</a> with predefined <a class="el" href="communicationPolicy.html">communication policy</a> and <a class="el" href="graphPolicy.html">graph policy</a>.</p>
<h2>Configure the GrayBat Cage</h2>
<ol type="1">
<li>Include GrayBat umbrella header and predefined functors for graph generation and graph mapping. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;graybat.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pattern/GridDiagonal.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mapping/Consecutive.hpp&gt;</span></div>
</div><!-- fragment --></li>
<li>Define communication policy to use (boost.MPI). <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">graybat::communicationPolicy::BMPI</a> CommunicationPolicy;</div>
</div><!-- fragment --></li>
<li>Define graph policy to use (boost graph library). <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classgraybat_1_1graphPolicy_1_1BGL.html">graybat::graphPolicy::BGL&lt;&gt;</a> GraphPolicy;</div>
</div><!-- fragment --></li>
<li>Define cage through policies. <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="structgraybat_1_1Cage.html">graybat::Cage&lt;CommunicatonPolicy, GraphPolicy&gt;</a> Cage;</div>
</div><!-- fragment --></li>
<li>Create Cage instance with graph creation functor that describes the communication <a class="el" href="communicationPattern.html">pattern</a>. <div class="fragment"><div class="line">Cage cage(<a class="code" href="structgraybat_1_1pattern_1_1GridDiagonal.html">graybat::pattern::GridDiagonal</a>(100,100))</div>
</div><!-- fragment --></li>
</ol>
<h2>Mapping Operations</h2>
<ol type="1">
<li><b>distribute</b>: Distributes vertices of the graph to peer(s) based on a <a class="el" href="mapping.html">mapping</a>. <div class="fragment"><div class="line">cage.distribute(<a class="code" href="structgraybat_1_1mapping_1_1Consecutive.html">graybat::mapping::Consecutive</a>());</div>
</div><!-- fragment --></li>
<li><b>hostedVertices</b>: The vertices mapped to the peer itself are called hosted vertices. <div class="fragment"><div class="line"><span class="keyword">typedef</span> Cage::Vertex Vertex;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Iterate over all vertices that I host</span></div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    std::cout &lt;&lt; vertex.id &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h2>Graph Operations</h2>
<p>A peer is responsible for the communication of all its hosted vertices. Therefore, the common approach for communication in GrayBat is to iterate over the set of hosted vertices and send data to adjacent vertices which are connected with an outgoing edge and receive data from adjacent vertices which are connected with an incoming edge.</p>
<ol type="1">
<li><b>getOutEdges</b>: Retrieve outgoing edges of hosted vertices. This information can be used to send data to adjacent vertices. <div class="fragment"><div class="line"><span class="keyword">typedef</span> Cage::Edge Edge;</div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> outEdge : cage.getOutEdges(vertex)){</div>
<div class="line">        Vertex destVertex = outEdge.first;</div>
<div class="line">        Edge   destEdge   = outEdge.second;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>getInEdges</b>: Retrieve incoming edges of hosted vertices. This information can be used to receive data from adjacent vertices. <div class="fragment"><div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> inEdge : cage.getInEdges(vertex)){</div>
<div class="line">        Vertex srcVertex = inEdge.first;</div>
<div class="line">        Edge   srcEdge   = inEdge.second;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h2>Point to Point Communication Operations</h2>
<ul>
<li><b>send/asyncSend</b>: Send synchronous and asynchronous data. The asynchronous version of send returns an event, which can be waited for or tested for its state. <div class="fragment"><div class="line"><span class="keyword">typedef</span> Cage::Edge  Edge;</div>
<div class="line"><span class="keyword">typedef</span> Cage::Event Event;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Some data that should be send</span></div>
<div class="line">std::vector&lt;int&gt; data(100,1);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> outEdge : cage.getOutEdges(vertex)){</div>
<div class="line">        Vertex destVertex = outEdge.first;</div>
<div class="line">        Edge   destEdge   = outEdge.second;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Synchronous</span></div>
<div class="line">        cage.send(destVertex, destEdge, data);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Asynchronous</span></div>
<div class="line">        Event e = cage.asyncSend(destVertex, destEdge, data);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Wait for and test event</span></div>
<div class="line">        e.wait();</div>
<div class="line">        <span class="keywordtype">bool</span> eventState = e.ready();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>recv/asyncRecv</b>: Receive synchronous and asynchronous data. The asynchronous version of recv returns an event, which can be waited for or tested for its state. <div class="fragment"><div class="line"><span class="keyword">typedef</span> Cage::Edge  Edge;</div>
<div class="line"><span class="keyword">typedef</span> Cage::Event Event;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Some data that should be send</span></div>
<div class="line">std::vector&lt;int&gt; data(100,1);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> inEdge : cage.getInEdges(vertex)){</div>
<div class="line">        Vertex srcVertex = inEdge.first;</div>
<div class="line">        Edge   srcEdge   = inEdge.second;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Synchronous receive</span></div>
<div class="line">        cage.recv(destVertex, destEdge, data);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Asynchronous receive</span></div>
<div class="line">        Event e = cage.asyncRecv(destVertex, destEdge, data);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Wait for and test event</span></div>
<div class="line">        e.wait();</div>
<div class="line">        <span class="keywordtype">bool</span> eventState = e.ready();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h2>Collective Communication Operations</h2>
<ul>
<li><b>reduce</b>: Reduce vector of data with binary operator and receive by some root vertex. <div class="fragment"><div class="line">Vertex rootVertex = cage.getVertex(0);</div>
<div class="line"></div>
<div class="line">std::vector&lt;int&gt; send(100);</div>
<div class="line">std::vector&lt;int&gt; recv(100);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Each vertex need to reduce its data, the root receives reduction.</span></div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    cage.reduce(rootVertex, vertex, std::plus&lt;int&gt;, send, recv);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>allReduce</b>: Reduce vector of data and receive them by every vertex. <div class="fragment"><div class="line">std::vector&lt;int&gt; send(100);</div>
<div class="line">std::vector&lt;int&gt; recv(100);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Each vertex need to reduce its data, all receive reduction.</span></div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    cage.allReduce(rootVertex, vertex, std::plus&lt;int&gt;, send, recv);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>gather</b>: Root vertex collects data from each vertex. <div class="fragment"><div class="line">Vertex rootVertex = cage.getVertex(0);</div>
<div class="line"></div>
<div class="line">std::vector&lt;int&gt; send(10);</div>
<div class="line">std::vector&lt;int&gt; recv(10 * cage.getVertices().size());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Each vertex need to send its data, the root receives</span></div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    cage.gather(rootVertex, vertex, send, recv);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>allGather</b>: Data is send to all vertices. <div class="fragment"><div class="line">std::vector&lt;int&gt; send(10);</div>
<div class="line">std::vector&lt;int&gt; recv(10 * cage.getVertices().size());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Each vertex need to send its data, all receive.</span></div>
<div class="line"><span class="keywordflow">for</span>(Vertex vertex: cage.hostedVertices){</div>
<div class="line">    cage.allGather(vertex, send, recv);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>synchronize</b>: Synchronize all peers (including their hosted vertices). <div class="fragment"><div class="line">cage.synchronize();</div>
</div><!-- fragment --></li>
</ul>
<h2>Further Links</h2>
<ul>
<li><a class="el" href="communicationPolicy.html">Communication Policy</a></li>
<li><a class="el" href="graphPolicy.html">Graph Policy</a></li>
<li><a class="el" href="communicationPattern.html">Communication Pattern</a></li>
<li><a class="el" href="mapping.html">Vertex Mapping</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Apr 28 2015 16:15:35 for GrayBat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
