<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>GrayBat: graybat::communicationPolicy::BMPI Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GrayBat
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Graph Approach for Highly Generic Communication Schemes Based on Adaptive Topologies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structgraybat_1_1communicationPolicy_1_1BMPI.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="classgraybat_1_1communicationPolicy_1_1BMPI-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graybat::communicationPolicy::BMPI Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the <a class="el" href="structgraybat_1_1Cage.html" title="The Communication And Graph Environment enables to communicate on basis of a graph with methods of a ...">Cage</a> communicationPolicy interface based on the MPI implementation boost::mpi.  
 <a href="structgraybat_1_1communicationPolicy_1_1BMPI.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BMPI_8hpp_source.html">BMPI.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context represents a set of peers which are able to communicate with each other.  <a href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event is returned by non-blocking communication operations and can be asked whether an operation has finished or it can be waited for this operation to be finished.  <a href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6a2171b8afb715c7e69adc2c0ac57009"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a2171b8afb715c7e69adc2c0ac57009"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>Tag</b></td></tr>
<tr class="separator:a6a2171b8afb715c7e69adc2c0ac57009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23535a3d1e68d826698597fadfee1e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad23535a3d1e68d826698597fadfee1e2"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ContextID</b></td></tr>
<tr class="separator:ad23535a3d1e68d826698597fadfee1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0d671244951f5db3c73d4fa6c1e9eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b0d671244951f5db3c73d4fa6c1e9eb"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>VAddr</b></td></tr>
<tr class="separator:a5b0d671244951f5db3c73d4fa6c1e9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67441e04c44cf91f1e1fc0ac4369d43f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67441e04c44cf91f1e1fc0ac4369d43f"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>MsgType</b></td></tr>
<tr class="separator:a67441e04c44cf91f1e1fc0ac4369d43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e24bdc0139ff12412e079e12ea4fc94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e24bdc0139ff12412e079e12ea4fc94"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>Uri</b></td></tr>
<tr class="separator:a6e24bdc0139ff12412e079e12ea4fc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Point to Point Communication Interface</div></td></tr>
<tr class="memitem:a68444513404ebd1548f34cbf3a2c3cc2"><td class="memTemplParams" colspan="2">template&lt;typename T_Send &gt; </td></tr>
<tr class="memitem:a68444513404ebd1548f34cbf3a2c3cc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html">Event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a68444513404ebd1548f34cbf3a2c3cc2">asyncSend</a> (const VAddr destVAddr, const Tag tag, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData)</td></tr>
<tr class="memdesc:a68444513404ebd1548f34cbf3a2c3cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non blocking transmission of a message sendData to peer with virtual address destVAddr.  <a href="#a68444513404ebd1548f34cbf3a2c3cc2">More...</a><br /></td></tr>
<tr class="separator:a68444513404ebd1548f34cbf3a2c3cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798111a6407368dc1b33b9893d9d1330"><td class="memTemplParams" colspan="2">template&lt;typename T_Send &gt; </td></tr>
<tr class="memitem:a798111a6407368dc1b33b9893d9d1330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a798111a6407368dc1b33b9893d9d1330">send</a> (const VAddr destVAddr, const Tag tag, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData)</td></tr>
<tr class="memdesc:a798111a6407368dc1b33b9893d9d1330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking transmission of a message sendData to peer with virtual address destVAddr.  <a href="#a798111a6407368dc1b33b9893d9d1330">More...</a><br /></td></tr>
<tr class="separator:a798111a6407368dc1b33b9893d9d1330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092b709e200b44cacf32909e9dace56b"><td class="memTemplParams" colspan="2">template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:a092b709e200b44cacf32909e9dace56b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html">Event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a092b709e200b44cacf32909e9dace56b">asyncRecv</a> (const VAddr srcVAddr, const Tag tag, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a092b709e200b44cacf32909e9dace56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non blocking receive of a message recvData from peer with virtual address srcVAddr.  <a href="#a092b709e200b44cacf32909e9dace56b">More...</a><br /></td></tr>
<tr class="separator:a092b709e200b44cacf32909e9dace56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4201b53dcff9d3acef8724031d93a8fd"><td class="memTemplParams" colspan="2">template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:a4201b53dcff9d3acef8724031d93a8fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a4201b53dcff9d3acef8724031d93a8fd">recv</a> (const VAddr srcVAddr, const Tag tag, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a4201b53dcff9d3acef8724031d93a8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking receive of a message recvData from peer with virtual address srcVAddr.  <a href="#a4201b53dcff9d3acef8724031d93a8fd">More...</a><br /></td></tr>
<tr class="separator:a4201b53dcff9d3acef8724031d93a8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective Communication Interface</div></td></tr>
<tr class="memitem:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a37fcb4dced08f33b4eee2adabf25fe0f">gather</a> (const VAddr rootVAddr, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size.  <a href="#a37fcb4dced08f33b4eee2adabf25fe0f">More...</a><br /></td></tr>
<tr class="separator:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772c45a8a2ec8ae749fef75ca2439cee"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a772c45a8a2ec8ae749fef75ca2439cee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a772c45a8a2ec8ae749fef75ca2439cee">gatherVar</a> (const VAddr rootVAddr, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a772c45a8a2ec8ae749fef75ca2439cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>.  <a href="#a772c45a8a2ec8ae749fef75ca2439cee">More...</a><br /></td></tr>
<tr class="separator:a772c45a8a2ec8ae749fef75ca2439cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadfee42ac90516c1158292da79b0345"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:abadfee42ac90516c1158292da79b0345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#abadfee42ac90516c1158292da79b0345">allGather</a> (<a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:abadfee42ac90516c1158292da79b0345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em>  <a href="#abadfee42ac90516c1158292da79b0345">More...</a><br /></td></tr>
<tr class="separator:abadfee42ac90516c1158292da79b0345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a365caf09acb118502623527c70668e"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a0a365caf09acb118502623527c70668e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a0a365caf09acb118502623527c70668e">allGatherVar</a> (const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a0a365caf09acb118502623527c70668e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>.  <a href="#a0a365caf09acb118502623527c70668e">More...</a><br /></td></tr>
<tr class="separator:a0a365caf09acb118502623527c70668e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1263d7d13beec1fe7267696c908d6eb"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:ad1263d7d13beec1fe7267696c908d6eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#ad1263d7d13beec1fe7267696c908d6eb">scatter</a> (const VAddr rootVAddr, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ad1263d7d13beec1fe7267696c908d6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data.  <a href="#ad1263d7d13beec1fe7267696c908d6eb">More...</a><br /></td></tr>
<tr class="separator:ad1263d7d13beec1fe7267696c908d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1558d37c09b31ce63e7926f183515fa5"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a1558d37c09b31ce63e7926f183515fa5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a1558d37c09b31ce63e7926f183515fa5">allToAll</a> (const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a1558d37c09b31ce63e7926f183515fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data)  <a href="#a1558d37c09b31ce63e7926f183515fa5">More...</a><br /></td></tr>
<tr class="separator:a1558d37c09b31ce63e7926f183515fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7db3cd7545e989f749ee863d291ce0"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </td></tr>
<tr class="memitem:a8e7db3cd7545e989f749ee863d291ce0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a8e7db3cd7545e989f749ee863d291ce0">reduce</a> (const VAddr rootVAddr, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_Op op, const T_Send &amp;sendData, const T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a8e7db3cd7545e989f749ee863d291ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc.  <a href="#a8e7db3cd7545e989f749ee863d291ce0">More...</a><br /></td></tr>
<tr class="separator:a8e7db3cd7545e989f749ee863d291ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0dd7f1c36157182cf0d0545879a6b8"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </td></tr>
<tr class="memitem:aed0dd7f1c36157182cf0d0545879a6b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aed0dd7f1c36157182cf0d0545879a6b8">allReduce</a> (const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:aed0dd7f1c36157182cf0d0545879a6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers.  <a href="#aed0dd7f1c36157182cf0d0545879a6b8">More...</a><br /></td></tr>
<tr class="separator:aed0dd7f1c36157182cf0d0545879a6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb70359df916ef746f5cfbe92c8d156"><td class="memTemplParams" colspan="2">template&lt;typename T_SendRecv &gt; </td></tr>
<tr class="memitem:a3fb70359df916ef746f5cfbe92c8d156"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a3fb70359df916ef746f5cfbe92c8d156">broadcast</a> (const VAddr rootVAddr, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context, const T_SendRecv &amp;data)</td></tr>
<tr class="memdesc:a3fb70359df916ef746f5cfbe92c8d156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data.  <a href="#a3fb70359df916ef746f5cfbe92c8d156">More...</a><br /></td></tr>
<tr class="separator:a3fb70359df916ef746f5cfbe92c8d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99355d8aae18e14c59b82c4ab4e2c29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa99355d8aae18e14c59b82c4ab4e2c29"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aa99355d8aae18e14c59b82c4ab4e2c29">synchronize</a> (const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> context)</td></tr>
<tr class="memdesc:aa99355d8aae18e14c59b82c4ab4e2c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all peers within <em>context</em> to the same point in the programm execution (barrier). <br /></td></tr>
<tr class="separator:aa99355d8aae18e14c59b82c4ab4e2c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cb4b8fa14af3cd34fc4dd8c3af6baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#ae2cb4b8fa14af3cd34fc4dd8c3af6baa">synchronize</a> ()</td></tr>
<tr class="memdesc:ae2cb4b8fa14af3cd34fc4dd8c3af6baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all peers within the globalContext in the programm execution (barrier).  <a href="#ae2cb4b8fa14af3cd34fc4dd8c3af6baa">More...</a><br /></td></tr>
<tr class="separator:ae2cb4b8fa14af3cd34fc4dd8c3af6baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Context Management Interface</div></td></tr>
<tr class="memitem:a332c965a70e219be6ad6b42cd59eb306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a332c965a70e219be6ad6b42cd59eb306"></a>
<a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a332c965a70e219be6ad6b42cd59eb306">createContext</a> (const std::vector&lt; VAddr &gt; vAddrs, const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a> oldContext)</td></tr>
<tr class="memdesc:a332c965a70e219be6ad6b42cd59eb306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new context from peer <em>ids</em> of an <em>oldContext</em> <br /></td></tr>
<tr class="separator:a332c965a70e219be6ad6b42cd59eb306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaaec7667d29a126cfc883cf552da31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaaaec7667d29a126cfc883cf552da31"></a>
<a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aaaaaec7667d29a126cfc883cf552da31">getGlobalContext</a> ()</td></tr>
<tr class="memdesc:aaaaaec7667d29a126cfc883cf552da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context that contains all peers. <br /></td></tr>
<tr class="separator:aaaaaec7667d29a126cfc883cf552da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the <a class="el" href="structgraybat_1_1Cage.html" title="The Communication And Graph Environment enables to communicate on basis of a graph with methods of a ...">Cage</a> communicationPolicy interface based on the MPI implementation boost::mpi. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="gol_8cc-example.html#_a1">gol.cc</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abadfee42ac90516c1158292da79b0345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allGather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>same</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a365caf09acb118502623527c70668e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allGatherVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed0dd7f1c36157182cf0d0545879a6b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allReduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by all peers. It will have same size of sendData and contains the ith reduced sendData values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1558d37c09b31ce63e7926f183515fa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allToAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that each peer wants to send. Each peer will receive same number of data elements, but not the same data elements. sendData will be divided in equal chunks of data and is then distributed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all peer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a092b709e200b44cacf32909e9dace56b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html">Event</a> graybat::communicationPolicy::BMPI::asyncRecv </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>srcVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non blocking receive of a message recvData from peer with virtual address srcVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVAddr</td><td>VAddr of peer that sended the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data reference of template type T will be received from sender peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html" title="An event is returned by non-blocking communication operations and can be asked whether an operation h...">Event</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a68444513404ebd1548f34cbf3a2c3cc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html">Event</a> graybat::communicationPolicy::BMPI::asyncSend </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>destVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non blocking transmission of a message sendData to peer with virtual address destVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destVAddr</td><td>VAddr of peer that will receive the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data reference of template type T will be. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Event.html" title="An event is returned by non-blocking communication operations and can be asked whether an operation h...">Event</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3fb70359df916ef746f5cfbe92c8d156"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_SendRecv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::broadcast </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_SendRecv &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to scatter where every peer receives different data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Source peer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will send to the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37fcb4dced08f33b4eee2adabf25fe0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::gather </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. Data of all peers in the <em>context</em> need to have <b>same</b> size(). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that peer with virtual address <em>rootVAddr</em> will receive. <em>recvData</em> of all other members of the <em>context</em> will be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a772c45a8a2ec8ae749fef75ca2439cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::gatherVar </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. The Data can have <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> peers, that peer with <em>rootVAddr</em> will receive. <em>recvData</em> of all other peers of the <em>context</em> will be empty. The received data is ordered by the VAddr of the peers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4201b53dcff9d3acef8724031d93a8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::recv </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>srcVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking receive of a message recvData from peer with virtual address srcVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVAddr</td><td>VAddr of peer that sended the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data reference of template type T will be received from sender peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e7db3cd7545e989f749ee863d291ce0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::reduce </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that will receive the result of reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by peer with <em>rootVAddr</em>. It will have same size of sendData and contains the ith reduced sendData values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1263d7d13beec1fe7267696c908d6eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::scatter </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to broadcast where every peer receives the same data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that want to distribute its data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will distribute over the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a798111a6407368dc1b33b9893d9d1330"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::send </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>destVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking transmission of a message sendData to peer with virtual address destVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destVAddr</td><td>VAddr of peer that will receive the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td><a class="el" href="classgraybat_1_1communicationPolicy_1_1BMPI_1_1Context.html" title="A context represents a set of peers which are able to communicate with each other. ">Context</a> in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data reference of template type T will be send to receiver peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2cb4b8fa14af3cd34fc4dd8c3af6baa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::synchronize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronizes all peers within the globalContext in the programm execution (barrier). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aaaaaec7667d29a126cfc883cf552da31" title="Returns the context that contains all peers. ">getGlobalContext()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/communicationPolicy/<a class="el" href="BMPI_8hpp_source.html">BMPI.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>graybat</b></li><li class="navelem"><b>communicationPolicy</b></li><li class="navelem"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a></li>
    <li class="footer">Generated on Wed Apr 29 2015 11:41:44 for GrayBat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
