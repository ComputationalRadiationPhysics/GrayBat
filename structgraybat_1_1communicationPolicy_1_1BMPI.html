<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Graybat: graybat::communicationPolicy::BMPI Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Graybat
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Graph Approach for Highly Generic Communication Schemes Based on Adaptive Topologies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structgraybat_1_1communicationPolicy_1_1BMPI.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgraybat_1_1communicationPolicy_1_1BMPI-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graybat::communicationPolicy::BMPI Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the <a class="el" href="structgraybat_1_1Cage.html" title="The Communication And Graph Environment enables to communicate on basis of a graph with methods of a ...">Cage</a> communicationPolicy interface based on the MPI implementation boost::mpi.  
 <a href="structgraybat_1_1communicationPolicy_1_1BMPI.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BMPI_8hpp_source.html">BMPI.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for graybat::communicationPolicy::BMPI:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structgraybat_1_1communicationPolicy_1_1BMPI.png" usemap="#graybat::communicationPolicy::BMPI_map" alt=""/>
  <map id="graybat::communicationPolicy::BMPI_map" name="graybat::communicationPolicy::BMPI_map">
<area href="structgraybat_1_1communicationPolicy_1_1Base.html" alt="graybat::communicationPolicy::Base&lt; BMPI &gt;" shape="rect" coords="0,0,267,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8d250a80c1b23afea7da0aad7f008d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d250a80c1b23afea7da0aad7f008d00"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Tag</b> = typename graybat::communicationPolicy::Tag&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a> &gt;</td></tr>
<tr class="separator:a8d250a80c1b23afea7da0aad7f008d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330e0f2f8ec3428af2ea9dd2d5695175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a330e0f2f8ec3428af2ea9dd2d5695175"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ContextID</b> = typename graybat::communicationPolicy::ContextID&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a> &gt;</td></tr>
<tr class="separator:a330e0f2f8ec3428af2ea9dd2d5695175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cba626cca2151ace6a47bd0e51b64b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8cba626cca2151ace6a47bd0e51b64b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MsgType</b> = typename graybat::communicationPolicy::MsgType&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a> &gt;</td></tr>
<tr class="separator:ac8cba626cca2151ace6a47bd0e51b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac214b2b6b3b852c387ebb3e3512555f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac214b2b6b3b852c387ebb3e3512555f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VAddr</b> = typename graybat::communicationPolicy::VAddr&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a> &gt;</td></tr>
<tr class="separator:ac214b2b6b3b852c387ebb3e3512555f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571329de1fa15aa9e8fedcd9d70c6cb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a571329de1fa15aa9e8fedcd9d70c6cb1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b> = typename graybat::communicationPolicy::Context&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a> &gt;</td></tr>
<tr class="separator:a571329de1fa15aa9e8fedcd9d70c6cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdda3b27c1c7a556ea87368a0e02c3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbdda3b27c1c7a556ea87368a0e02c3e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Event</b> = typename graybat::communicationPolicy::Event&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a> &gt;</td></tr>
<tr class="separator:afbdda3b27c1c7a556ea87368a0e02c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d4867df284c0642aa17cdefc68c676"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38d4867df284c0642aa17cdefc68c676"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Config</b> = typename graybat::communicationPolicy::Config&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a> &gt;</td></tr>
<tr class="separator:a38d4867df284c0642aa17cdefc68c676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dff8c14cca1780c399d51b7eb6df610"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dff8c14cca1780c399d51b7eb6df610"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Uri</b> = int</td></tr>
<tr class="separator:a3dff8c14cca1780c399d51b7eb6df610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structgraybat_1_1communicationPolicy_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base&lt; BMPI &gt;</a></td></tr>
<tr class="memitem:a8809cc88306f4411eff43b185d4a12ba inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8809cc88306f4411eff43b185d4a12ba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CommunicationPolicy</b> = <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a></td></tr>
<tr class="separator:a8809cc88306f4411eff43b185d4a12ba inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61555bfaae515788f4832c0f78bc36f4 inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61555bfaae515788f4832c0f78bc36f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VAddr</b> = typename graybat::communicationPolicy::VAddr&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">CommunicationPolicy</a> &gt;</td></tr>
<tr class="separator:a61555bfaae515788f4832c0f78bc36f4 inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced4ab808a9c345a0e698d21736f3a2c inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aced4ab808a9c345a0e698d21736f3a2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Tag</b> = typename graybat::communicationPolicy::Tag&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">CommunicationPolicy</a> &gt;</td></tr>
<tr class="separator:aced4ab808a9c345a0e698d21736f3a2c inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a885bada327fddc91cfe4515af6471 inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a885bada327fddc91cfe4515af6471"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b> = typename graybat::communicationPolicy::Context&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">CommunicationPolicy</a> &gt;</td></tr>
<tr class="separator:a12a885bada327fddc91cfe4515af6471 inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc51f670372dfb2d7f8474a5a0f5e89 inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fc51f670372dfb2d7f8474a5a0f5e89"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Event</b> = typename graybat::communicationPolicy::Event&lt; <a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">CommunicationPolicy</a> &gt;</td></tr>
<tr class="separator:a2fc51f670372dfb2d7f8474a5a0f5e89 inherit pub_types_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f47c4f3521415aca2f6f6321b8bb87a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f47c4f3521415aca2f6f6321b8bb87a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BMPI</b> (Config const config)</td></tr>
<tr class="separator:a7f47c4f3521415aca2f6f6321b8bb87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Point to Point Communication Interface</div></td></tr>
<tr class="memitem:a798111a6407368dc1b33b9893d9d1330"><td class="memTemplParams" colspan="2">template&lt;typename T_Send &gt; </td></tr>
<tr class="memitem:a798111a6407368dc1b33b9893d9d1330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a798111a6407368dc1b33b9893d9d1330">send</a> (const VAddr destVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, const T_Send &amp;sendData)</td></tr>
<tr class="memdesc:a798111a6407368dc1b33b9893d9d1330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking transmission of a message sendData to peer with virtual address destVAddr.  <a href="#a798111a6407368dc1b33b9893d9d1330">More...</a><br /></td></tr>
<tr class="separator:a798111a6407368dc1b33b9893d9d1330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68444513404ebd1548f34cbf3a2c3cc2"><td class="memTemplParams" colspan="2">template&lt;typename T_Send &gt; </td></tr>
<tr class="memitem:a68444513404ebd1548f34cbf3a2c3cc2"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a68444513404ebd1548f34cbf3a2c3cc2">asyncSend</a> (const VAddr destVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, const T_Send &amp;sendData)</td></tr>
<tr class="memdesc:a68444513404ebd1548f34cbf3a2c3cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non blocking transmission of a message sendData to peer with virtual address destVAddr.  <a href="#a68444513404ebd1548f34cbf3a2c3cc2">More...</a><br /></td></tr>
<tr class="separator:a68444513404ebd1548f34cbf3a2c3cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4201b53dcff9d3acef8724031d93a8fd"><td class="memTemplParams" colspan="2">template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:a4201b53dcff9d3acef8724031d93a8fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a4201b53dcff9d3acef8724031d93a8fd">recv</a> (const VAddr srcVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a4201b53dcff9d3acef8724031d93a8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking receive of a message recvData from peer with virtual address srcVAddr.  <a href="#a4201b53dcff9d3acef8724031d93a8fd">More...</a><br /></td></tr>
<tr class="separator:a4201b53dcff9d3acef8724031d93a8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8346f1fab44e4160819a352f264884"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b8346f1fab44e4160819a352f264884"></a>
template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:a9b8346f1fab44e4160819a352f264884"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><b>recv</b> (const Context context, T_Recv &amp;recvData)</td></tr>
<tr class="separator:a9b8346f1fab44e4160819a352f264884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092b709e200b44cacf32909e9dace56b"><td class="memTemplParams" colspan="2">template&lt;typename T_Recv &gt; </td></tr>
<tr class="memitem:a092b709e200b44cacf32909e9dace56b"><td class="memTemplItemLeft" align="right" valign="top">Event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a092b709e200b44cacf32909e9dace56b">asyncRecv</a> (const VAddr srcVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a092b709e200b44cacf32909e9dace56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non blocking receive of a message recvData from peer with virtual address srcVAddr.  <a href="#a092b709e200b44cacf32909e9dace56b">More...</a><br /></td></tr>
<tr class="separator:a092b709e200b44cacf32909e9dace56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective Communication Interface</div></td></tr>
<tr class="memitem:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a37fcb4dced08f33b4eee2adabf25fe0f">gather</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size.  <a href="#a37fcb4dced08f33b4eee2adabf25fe0f">More...</a><br /></td></tr>
<tr class="separator:a37fcb4dced08f33b4eee2adabf25fe0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772c45a8a2ec8ae749fef75ca2439cee"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a772c45a8a2ec8ae749fef75ca2439cee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a772c45a8a2ec8ae749fef75ca2439cee">gatherVar</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a772c45a8a2ec8ae749fef75ca2439cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>.  <a href="#a772c45a8a2ec8ae749fef75ca2439cee">More...</a><br /></td></tr>
<tr class="separator:a772c45a8a2ec8ae749fef75ca2439cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadfee42ac90516c1158292da79b0345"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:abadfee42ac90516c1158292da79b0345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#abadfee42ac90516c1158292da79b0345">allGather</a> (Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:abadfee42ac90516c1158292da79b0345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em>  <a href="#abadfee42ac90516c1158292da79b0345">More...</a><br /></td></tr>
<tr class="separator:abadfee42ac90516c1158292da79b0345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a365caf09acb118502623527c70668e"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a0a365caf09acb118502623527c70668e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a0a365caf09acb118502623527c70668e">allGatherVar</a> (const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a0a365caf09acb118502623527c70668e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>.  <a href="#a0a365caf09acb118502623527c70668e">More...</a><br /></td></tr>
<tr class="separator:a0a365caf09acb118502623527c70668e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1263d7d13beec1fe7267696c908d6eb"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:ad1263d7d13beec1fe7267696c908d6eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#ad1263d7d13beec1fe7267696c908d6eb">scatter</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ad1263d7d13beec1fe7267696c908d6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data.  <a href="#ad1263d7d13beec1fe7267696c908d6eb">More...</a><br /></td></tr>
<tr class="separator:ad1263d7d13beec1fe7267696c908d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1558d37c09b31ce63e7926f183515fa5"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv &gt; </td></tr>
<tr class="memitem:a1558d37c09b31ce63e7926f183515fa5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a1558d37c09b31ce63e7926f183515fa5">allToAll</a> (const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a1558d37c09b31ce63e7926f183515fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data)  <a href="#a1558d37c09b31ce63e7926f183515fa5">More...</a><br /></td></tr>
<tr class="separator:a1558d37c09b31ce63e7926f183515fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee4b7a6d3026127cac5b25aa7d860f6"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </td></tr>
<tr class="memitem:abee4b7a6d3026127cac5b25aa7d860f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#abee4b7a6d3026127cac5b25aa7d860f6">reduce</a> (const VAddr rootVAddr, const Context context, const T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:abee4b7a6d3026127cac5b25aa7d860f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc.  <a href="#abee4b7a6d3026127cac5b25aa7d860f6">More...</a><br /></td></tr>
<tr class="separator:abee4b7a6d3026127cac5b25aa7d860f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0dd7f1c36157182cf0d0545879a6b8"><td class="memTemplParams" colspan="2">template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </td></tr>
<tr class="memitem:aed0dd7f1c36157182cf0d0545879a6b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aed0dd7f1c36157182cf0d0545879a6b8">allReduce</a> (const Context context, T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:aed0dd7f1c36157182cf0d0545879a6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers.  <a href="#aed0dd7f1c36157182cf0d0545879a6b8">More...</a><br /></td></tr>
<tr class="separator:aed0dd7f1c36157182cf0d0545879a6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21dca81db3bd46870062ef978f00206"><td class="memTemplParams" colspan="2">template&lt;typename T_SendRecv &gt; </td></tr>
<tr class="memitem:ad21dca81db3bd46870062ef978f00206"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#ad21dca81db3bd46870062ef978f00206">broadcast</a> (const VAddr rootVAddr, const Context context, T_SendRecv &amp;data)</td></tr>
<tr class="memdesc:ad21dca81db3bd46870062ef978f00206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data.  <a href="#ad21dca81db3bd46870062ef978f00206">More...</a><br /></td></tr>
<tr class="separator:ad21dca81db3bd46870062ef978f00206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99355d8aae18e14c59b82c4ab4e2c29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa99355d8aae18e14c59b82c4ab4e2c29"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aa99355d8aae18e14c59b82c4ab4e2c29">synchronize</a> (const Context context)</td></tr>
<tr class="memdesc:aa99355d8aae18e14c59b82c4ab4e2c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all peers within <em>context</em> to the same point in the programm execution (barrier). <br /></td></tr>
<tr class="separator:aa99355d8aae18e14c59b82c4ab4e2c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cb4b8fa14af3cd34fc4dd8c3af6baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#ae2cb4b8fa14af3cd34fc4dd8c3af6baa">synchronize</a> ()</td></tr>
<tr class="memdesc:ae2cb4b8fa14af3cd34fc4dd8c3af6baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all peers within the globalContext in the programm execution (barrier).  <a href="#ae2cb4b8fa14af3cd34fc4dd8c3af6baa">More...</a><br /></td></tr>
<tr class="separator:ae2cb4b8fa14af3cd34fc4dd8c3af6baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Context Management Interface</div></td></tr>
<tr class="memitem:a4c65002f731605e7e6d80acdc1d4c678"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c65002f731605e7e6d80acdc1d4c678"></a>
Context&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#a4c65002f731605e7e6d80acdc1d4c678">splitContext</a> (const bool isMember, const Context oldContext)</td></tr>
<tr class="memdesc:a4c65002f731605e7e6d80acdc1d4c678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new context with all peers that declared isMember as true. <br /></td></tr>
<tr class="separator:a4c65002f731605e7e6d80acdc1d4c678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaaec7667d29a126cfc883cf552da31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaaaec7667d29a126cfc883cf552da31"></a>
Context&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aaaaaec7667d29a126cfc883cf552da31">getGlobalContext</a> ()</td></tr>
<tr class="memdesc:aaaaaec7667d29a126cfc883cf552da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context that contains all peers. <br /></td></tr>
<tr class="separator:aaaaaec7667d29a126cfc883cf552da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structgraybat_1_1communicationPolicy_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html">graybat::communicationPolicy::Base&lt; BMPI &gt;</a></td></tr>
<tr class="memitem:a7c7b3cd367ec07fa9d12ebbbb89dabb8 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c7b3cd367ec07fa9d12ebbbb89dabb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>send</b> (const VAddr destVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, const T_Send &amp;sendData)=delete</td></tr>
<tr class="separator:a7c7b3cd367ec07fa9d12ebbbb89dabb8 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfe96d75727357e0bbac4f8dad93a55 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dfe96d75727357e0bbac4f8dad93a55"></a>
Event&#160;</td><td class="memItemRight" valign="bottom"><b>asyncSend</b> (const VAddr destVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, const T_Send &amp;sendData)=delete</td></tr>
<tr class="separator:a7dfe96d75727357e0bbac4f8dad93a55 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1785dcc6035447fc3c2b1cd9fee9a4b5 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1785dcc6035447fc3c2b1cd9fee9a4b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>recv</b> (const VAddr srcVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, T_Recv &amp;recvData)=delete</td></tr>
<tr class="separator:a1785dcc6035447fc3c2b1cd9fee9a4b5 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7e5b0d65bfa0fcfa3377598eb79882 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c7e5b0d65bfa0fcfa3377598eb79882"></a>
Event&#160;</td><td class="memItemRight" valign="bottom"><b>recv</b> (const Context context, T_Recv &amp;recvData)=delete</td></tr>
<tr class="separator:a2c7e5b0d65bfa0fcfa3377598eb79882 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee3935d47f527c2802d3b88b546b0a2 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adee3935d47f527c2802d3b88b546b0a2"></a>
Event&#160;</td><td class="memItemRight" valign="bottom"><b>asyncRecv</b> (const VAddr srcVAddr, const <a class="el" href="structTag.html">Tag</a> tag, const Context context, T_Recv &amp;recvData)=delete</td></tr>
<tr class="separator:adee3935d47f527c2802d3b88b546b0a2 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db000db20b6cb8fd6e63f3d53e82090 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a3db000db20b6cb8fd6e63f3d53e82090">gather</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a3db000db20b6cb8fd6e63f3d53e82090 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size.  <a href="#a3db000db20b6cb8fd6e63f3d53e82090">More...</a><br /></td></tr>
<tr class="separator:a3db000db20b6cb8fd6e63f3d53e82090 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1434994bead59ef38b6eff8346538f0b inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a1434994bead59ef38b6eff8346538f0b">gatherVar</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a1434994bead59ef38b6eff8346538f0b inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>.  <a href="#a1434994bead59ef38b6eff8346538f0b">More...</a><br /></td></tr>
<tr class="separator:a1434994bead59ef38b6eff8346538f0b inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b409ea49d7aba2dee0c83e28dda1b65 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a1b409ea49d7aba2dee0c83e28dda1b65">allGather</a> (Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:a1b409ea49d7aba2dee0c83e28dda1b65 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em>  <a href="#a1b409ea49d7aba2dee0c83e28dda1b65">More...</a><br /></td></tr>
<tr class="separator:a1b409ea49d7aba2dee0c83e28dda1b65 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bad18907fcc45db9d4a119e726061a8 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a1bad18907fcc45db9d4a119e726061a8">allGatherVar</a> (const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData, std::vector&lt; unsigned &gt; &amp;recvCount)</td></tr>
<tr class="memdesc:a1bad18907fcc45db9d4a119e726061a8 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>.  <a href="#a1bad18907fcc45db9d4a119e726061a8">More...</a><br /></td></tr>
<tr class="separator:a1bad18907fcc45db9d4a119e726061a8 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ed07ce5f107f04926d7b7c39c9834e inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#af1ed07ce5f107f04926d7b7c39c9834e">scatter</a> (const VAddr rootVAddr, const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:af1ed07ce5f107f04926d7b7c39c9834e inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data.  <a href="#af1ed07ce5f107f04926d7b7c39c9834e">More...</a><br /></td></tr>
<tr class="separator:af1ed07ce5f107f04926d7b7c39c9834e inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4aa66d3ed33c810ae48ae762b432b14 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#ac4aa66d3ed33c810ae48ae762b432b14">allScatter</a> (const Context context, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ac4aa66d3ed33c810ae48ae762b432b14 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data)  <a href="#ac4aa66d3ed33c810ae48ae762b432b14">More...</a><br /></td></tr>
<tr class="separator:ac4aa66d3ed33c810ae48ae762b432b14 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bf74c91931b35b56fbb54ac535bc14 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#ad3bf74c91931b35b56fbb54ac535bc14">reduce</a> (const VAddr rootVAddr, const Context context, const T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ad3bf74c91931b35b56fbb54ac535bc14 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc.  <a href="#ad3bf74c91931b35b56fbb54ac535bc14">More...</a><br /></td></tr>
<tr class="separator:ad3bf74c91931b35b56fbb54ac535bc14 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77038454619b683f006ba149aea2dcb inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#ac77038454619b683f006ba149aea2dcb">allReduce</a> (const Context context, T_Op op, const T_Send &amp;sendData, T_Recv &amp;recvData)</td></tr>
<tr class="memdesc:ac77038454619b683f006ba149aea2dcb inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers.  <a href="#ac77038454619b683f006ba149aea2dcb">More...</a><br /></td></tr>
<tr class="separator:ac77038454619b683f006ba149aea2dcb inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431ed56b3d5ade805200b565ce98daa0 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#a431ed56b3d5ade805200b565ce98daa0">broadcast</a> (const VAddr rootVAddr, const Context context, T_SendRecv &amp;data)</td></tr>
<tr class="memdesc:a431ed56b3d5ade805200b565ce98daa0 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data.  <a href="#a431ed56b3d5ade805200b565ce98daa0">More...</a><br /></td></tr>
<tr class="separator:a431ed56b3d5ade805200b565ce98daa0 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4e72365c6ad134ba6e31abd8fa2163 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc4e72365c6ad134ba6e31abd8fa2163"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraybat_1_1communicationPolicy_1_1Base.html#abc4e72365c6ad134ba6e31abd8fa2163">synchronize</a> (const Context context)</td></tr>
<tr class="memdesc:abc4e72365c6ad134ba6e31abd8fa2163 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all peers within <em>context</em> to the same point in the programm execution (barrier). <br /></td></tr>
<tr class="separator:abc4e72365c6ad134ba6e31abd8fa2163 inherit pub_methods_structgraybat_1_1communicationPolicy_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the <a class="el" href="structgraybat_1_1Cage.html" title="The Communication And Graph Environment enables to communicate on basis of a graph with methods of a ...">Cage</a> communicationPolicy interface based on the MPI implementation boost::mpi. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="anyrecv_8cpp-example.html#_a1">anyrecv.cpp</a>, <a class="el" href="chain_8cpp-example.html#_a1">chain.cpp</a>, <a class="el" href="forward_8cpp-example.html#_a1">forward.cpp</a>, <a class="el" href="gol_8cpp-example.html#_a1">gol.cpp</a>, and <a class="el" href="ring_8cpp-example.html#_a1">ring.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abadfee42ac90516c1158292da79b0345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allGather </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all members of the <em>context</em> and transmits it as a list to every peer in the <em>context</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>same</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a365caf09acb118502623527c70668e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allGatherVar </td>
          <td>(</td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em>. Size of <em>sendData</em> can vary in size. The data is received by every peer in the <em>context</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends with <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that all peers* will receive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed0dd7f1c36157182cf0d0545879a6b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allReduce </td>
          <td>(</td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by all peers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by all peers. It will have same size of sendData and contains the ith reduced sendData values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1558d37c09b31ce63e7926f183515fa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::allToAll </td>
          <td>(</td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distributes <em>sendData</em> of all peer in the <em>context</em> to all peers in the <em>context</em>. Every peer will receive data from every other peer (also the own data) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that each peer wants to send. Each peer will receive same number of data elements, but not the same data elements. sendData will be divided in equal chunks of data and is then distributed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all peer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a092b709e200b44cacf32909e9dace56b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Event graybat::communicationPolicy::BMPI::asyncRecv </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>srcVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non blocking receive of a message recvData from peer with virtual address srcVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVAddr</td><td>VAddr of peer that sended the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data reference of template type T will be received from sender peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event </dd></dl>

</div>
</div>
<a class="anchor" id="a68444513404ebd1548f34cbf3a2c3cc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Event graybat::communicationPolicy::BMPI::asyncSend </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>destVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non blocking transmission of a message sendData to peer with virtual address destVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destVAddr</td><td>VAddr of peer that will receive the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data reference of template type T will be. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event </dd></dl>

</div>
</div>
<a class="anchor" id="ad21dca81db3bd46870062ef978f00206"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_SendRecv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::broadcast </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_SendRecv &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive the same data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to scatter where every peer receives different data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Source peer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will send to the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37fcb4dced08f33b4eee2adabf25fe0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::gather </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all peers of the <em>context</em> and transmits it as a list to the peer with <em>rootVAddr</em>. Data of all peers has to be from the <b>same</b> size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. Data of all peers in the <em>context</em> need to have <b>same</b> size(). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> members, that peer with virtual address <em>rootVAddr</em> will receive. <em>recvData</em> of all other members of the <em>context</em> will be empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a772c45a8a2ec8ae749fef75ca2439cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::gatherVar </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects <em>sendData</em> from all members of the <em>context</em> with <b>varying</b> size and transmits it as a list to peer with <em>rootVAddr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>Peer that will receive collcted data from <em>context</em> members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to send Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer in the <em>context</em> sends. The Data can have <b>varying</b> size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from all <em>context</em> peers, that peer with <em>rootVAddr</em> will receive. <em>recvData</em> of all other peers of the <em>context</em> will be empty. The received data is ordered by the VAddr of the peers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvCount</td><td>Number of elements each peer sends (can by varying). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4201b53dcff9d3acef8724031d93a8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::recv </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>srcVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking receive of a message recvData from peer with virtual address srcVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcVAddr</td><td>VAddr of peer that sended the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data reference of template type T will be received from sender peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abee4b7a6d3026127cac5b25aa7d860f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv , typename T_Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::reduce </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction with a binary operator <em>op</em> on all <em>sendData</em> elements from all peers whithin the <em>context</em>. The result will be received by the peer with <em>rootVAddr</em>. Binary operations like std::plus, std::minus can be used. But, they can also be defined as binary operator simular to std::plus etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that will receive the result of reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Binary operator that should be used for reduction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that every peer contributes to the reduction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Reduced sendData that will be received by peer with <em>rootVAddr</em>. It will have same size of sendData and contains the ith reduced sendData values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1263d7d13beec1fe7267696c908d6eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send , typename T_Recv &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::scatter </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>rootVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Recv &amp;&#160;</td>
          <td class="paramname"><em>recvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distributes <em>sendData</em> from peer <em>rootVAddr</em> to all peers in <em>context</em>. Every peer will receive different data. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In Contrast to broadcast where every peer receives the same data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootVAddr</td><td>peer that want to distribute its data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Set of peers that want to receive Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data that peer with <em>rootVAddr</em> will distribute over the peers of the <em>context</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recvData</td><td>Data from peer with <em>rootVAddr</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a798111a6407368dc1b33b9893d9d1330"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Send &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::send </td>
          <td>(</td>
          <td class="paramtype">const VAddr&#160;</td>
          <td class="paramname"><em>destVAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_Send &amp;&#160;</td>
          <td class="paramname"><em>sendData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking transmission of a message sendData to peer with virtual address destVAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destVAddr</td><td>VAddr of peer that will receive the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Description of the message to better distinguish messages types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context in which both sender and receiver are included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendData</td><td>Data reference of template type T will be send to receiver peer. T need to provide the function data(), that returns the pointer to the data memory address. And the function size(), that return the amount of data elements to send. Notice, that std::vector and std::array implement this interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2cb4b8fa14af3cd34fc4dd8c3af6baa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void graybat::communicationPolicy::BMPI::synchronize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronizes all peers within the globalContext in the programm execution (barrier). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html#aaaaaec7667d29a126cfc883cf552da31" title="Returns the context that contains all peers. ">getGlobalContext()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/graybat/communicationPolicy/<a class="el" href="BMPI_8hpp_source.html">BMPI.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>graybat</b></li><li class="navelem"><b>communicationPolicy</b></li><li class="navelem"><a class="el" href="structgraybat_1_1communicationPolicy_1_1BMPI.html">BMPI</a></li>
    <li class="footer">Generated on Sat Dec 12 2015 23:15:07 for Graybat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
